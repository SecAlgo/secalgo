import pickle
from sa.Misc.Padding import pkcs7_pad, pkcs7_unpad
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random import random


class RoleS (process):
    def setup(K_IS, K_RS):
        Random.atfork()
    def run():
        await(False)
    def receive(msg=('msg1', (I, R, N_I)), from_ = I):
        K_IR = Random.new().read(32) #32 bytes = 256 bits, default AES keysize in SA
        iv_rs = Random.new().read(AES.block_size)
        cipher_rs = AES.new(K_RS, AES.MODE_CBC, iv_rs)
        msg_RS = pickle.dumps((K_IR, I)) # format input for encryption function
        padmsg_RS = pkcs7_pad(msg_RS)    # pad output to block length for CBC mode
        ct_RS = cipher_rs.encrypt(padmsg_RS) #encrypt padded, serialized plaintext
        ivct_RS = iv_rs + ct_RS #prepend initialization vector to ciphertext
        iv_is = Random.new().read(AES.block_size)
        cipher_is = AES.new(K_IS, AES.MODE_CBC, iv_is)
        msg_IS = pickle.dumps((N_I, R, K_IR, ivct_RS))
        padmsg_IS = pkcs7_pad(msg_IS)
        ct_IS = cipher_is.encrypt(padmsg_IS)
        ivct_IS = iv_is + ct_IS
        send(('msg2', ivct_IS), to = I)
class RoleI (process):
    def setup(S, K_IS, R):
        Random.atfork()
    def run():
        N_I = random.StrongRandom().getrandbits(128)
        send(('msg1', (self, R, N_I)), to = S)
        await(some(received(('msg2', enc_IS), from_ = _S)))
        cipher_is = AES.new(K_IS, AES.MODE_CBC, enc_IS[:16])
        padmsg_IS = cipher_is.decrypt(enc_IS[16:])
        msg_IS = pkcs7_unpad(padmsg_IS)
        N_I_ret, R_ret, K_IR, enc_RS = pickle.loads(msg_IS)
        if N_I_ret == N_I:
            if R_ret == R:
                send(('msg3', enc_RS), to = R)
                await(some(received(('msg4', enc_RI), from_ = _R)))
                cipher_ir = AES.new(K_IR, AES.MODE_CBC, enc_RI[:16])
                padmsg_RI = cipher_ir.decrypt(enc_RI[16:])
                msg_RI = pkcs7_unpad(padmsg_RI)
                N_R = pickle.loads(msg_RI)
                iv_ir = Random.new().read(AES.block_size)
                cipher_ir = AES.new(K_IR, AES.MODE_CBC, iv_ir)
                msg_IR = pickle.dumps(N_R - 1)
                padmsg_IR = pkcs7_pad(msg_IR)
                ct_IR = cipher_ir.encrypt(padmsg_IR)
                ivct_IR = iv_ir + ct_IR
                send(('msg5', ivct_IR), to = R)
                output('I - Key Exchange Complete')
class RoleR (process):
    def setup(S, K_RS):
        Random.atfork()
    def run():
        await(False)
    def receive(msg=('msg3', enc_RS), from_ = I):
        cipher_rs = AES.new(K_RS, AES.MODE_CBC, enc_RS[:16])
        padmsg_RS = cipher_rs.decrypt(enc_RS[16:])
        msg_RS = pkcs7_unpad(padmsg_RS)
        K_IR, I_ret = pickle.loads(msg_RS)
        if I_ret == I:
            N_R = random.StrongRandom().getrandbits(128)
            iv_ri = Random.new().read(AES.block_size)
            cipher_ri = AES.new(K_IR, AES.MODE_CBC, iv_ri)
            msg_RI = pickle.dumps(N_R)
            padmsg_RI = pkcs7_pad(msg_RI)
            ct_RI = cipher_ri.encrypt(padmsg_RI)
            ivct_RI = iv_ri + ct_RI
            send(('msg4', ivct_RI), to = I)
            await(some(received(('msg5', enc_IR), from_ = _I)))
            cipher_ri = AES.new(K_IR, AES.MODE_CBC, enc_IR[:16])
            padmsg_IR = cipher_ri.decrypt(enc_IR[16:])
            msg_IR = pkcs7_unpad(padmsg_IR)
            if pickle.loads(msg_IR) == N_R - 1:
                output('R - Key Exchange Complete')
def main():
    K_IS = Random.new().read(32)
    K_RS = Random.new().read(32)
    S = new(RoleS, (K_IS, K_RS))
    R = new(RoleR, (S, K_RS))
    I = new(RoleI, (S, K_IS, R))
    start(S)
    start(R)
    start(I)
