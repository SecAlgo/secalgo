import pickle
from Crypto import Random
from Crypto.Random import random
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad
def pcEncrypt(data, key):
    pubk = RSA.importKey(key)
    cipher = PKCS1_OAEP.new(pubk)
    try:
        ct = cipher.encrypt(data)
    except ValueError:
        sharedk = Random.new().read(32)
        iv = Random.new().read(AES.block_size)
        sharedCipher = AES.new(sharedk, AES.MODE_CBC, iv)
        dataCT = sharedCipher.encrypt(pad(data))
        keyCT = cipher.encrypt(sharedk)
        ct = keyCT + iv + dataCT
    return ct
def pcDecrypt(ct, key):
    privk = RSA.importKey(key)
    cipher = PKCS1_OAEP.new(privk)
    if len(ct) > (privk.size() // 8):
        sharedk = cipher.decrypt(ct[:256])
        iv = ct[256:272]
        sharedCipher = AES.new(sharedk, AES.MODE_CBC, iv)
        data = unpad(sharedCipher.decrypt(ct[272:]))
    else:
        data = cipher.decrypt(ct)
    return data
class RoleI (process):
    def setup(skI, R, pkR):
        Random.atfork()        
    def run():
        k = Random.new().read(32)
        h = SHA256.new(k)
        signer = PKCS1_v1_5.new(RSA.importKey(skI))
        sig = signer.sign(h)
        send(('encrypt_sign', pcEncrypt(pickle.dumps((k, sig)), pkR)), to = R)
        await(some(received(m, from_ = _R)))
        cipher = AES.new(k, AES.MODE_CBC, m[:16])
        s = pickle.loads(unpad(cipher.decrypt(m[16:])))
        output('DECRYPTED MESSAGE:', s)
class RoleR (process):
    def setup(skR, pkI):
        Random.atfork()
        self.s = 'secret'
    def run():
        await(False)
    def receive(msg=('encrypt_sign', m), from_ = I):
        k, sig = pickle.loads(pcDecrypt(m, skR))
        h = SHA256.new(k)
        verifier = PKCS1_v1_5.new(RSA.importKey(pkI))
        if verifier.verify(h, sig):
            iv = Random.new().read(AES.block_size)
            cipher = AES.new(k, AES.MODE_CBC, iv)
            send(iv + cipher.encrypt(pad(pickle.dumps(s))), to = I)
def main():
    skI = RSA.generate(2048)
    pkI = skI.publickey()
    skR = RSA.generate(2048)
    pkR = skR.publickey()
    R = new(RoleR, (skR.exportKey(), pkI.exportKey()))
    I = new(RoleI, (skI.exportKey(), R, pkR.exportKey()))
    start(I)
    start(R)
