import time, pickle
from Crypto import Random
from Crypto.Random import random
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad
def pcEncrypt(data, key):
    pubk = RSA.importKey(key)
    cipher = PKCS1_OAEP.new(pubk)
    try:
        ct = cipher.encrypt(data)
    except ValueError:
        sharedk = Random.new().read(32)
        iv = Random.new().read(AES.block_size)
        sharedCipher = AES.new(sharedk, AES.MODE_CBC, iv)
        dataCT = sharedCipher.encrypt(pad(data))
        keyCT = cipher.encrypt(sharedk)
        ct = keyCT + iv + dataCT
    return ct
def pcDecrypt(ct, key):
    privk = RSA.importKey(key)
    cipher = PKCS1_OAEP.new(privk)
    if len(ct) > (privk.size() // 8):
        sharedk = cipher.decrypt(ct[:256])
        iv = ct[256:272]
        sharedCipher = AES.new(sharedk, AES.MODE_CBC, iv)
        data = unpad(sharedCipher.decrypt(ct[272:]))
    else:
        data = cipher.decrypt(ct)
    return data
class roleA(process):
    def setup(B, S, skA, pkA, pkS):
        Random.atfork()
    def run():
        send(('msg01', self, B), to = S)
        await(some(received(('msg02', (A, _pkA, tA, sigA),
                             (_B, pkB, tB, sigB)), from_ = S), has = (A == self)))
        hA = SHA256.new(pickle.dumps((A, pkA, tA)))
        hB = SHA256.new(pickle.dumps((B, pkB, tB)))
        verifier = PKCS1_v1_5.new(RSA.importKey(pkS))
        if verifier.verify(hA, sigA) and verifier.verify(hB, sigB):
            kAB = Random.new().read(32)
            tAB = time.time()
            hAB = SHA256.new(pickle.dumps((kAB, tAB)))
            signer = PKCS1_v1_5.new(RSA.importKey(skA))
            sigAB = signer.sign(hAB)
            send(('msg03', (A, pkA, tA, sigA), (B, pkB, tB, sigB),
                  pcEncrypt(pickle.dumps(((kAB, tAB), sigAB)), pkB)), to = B)
            output('Initiator: Key Exchange Complete')
        else:
            output('Initiator: Could not verify certificates')
class roleB(process):
    def setup(S, skB, pkB, pkS):
        Random.atfork()
    def run():
        await(some(received(('msg03', (A, pkA, tA, sigA),
                             (B, _pkB, tB, sigB), encAB), from_ = A), has = (B == self)))
        hA = SHA256.new(pickle.dumps((A, pkA, tA)))
        hB = SHA256.new(pickle.dumps((B, pkB, tB)))
        verifierS = PKCS1_v1_5.new(RSA.importKey(pkS))
        if verifierS.verify(hA, sigA) and verifierS.verify(hB, sigB):
            (kAB, tAB), sigAB = pickle.loads(pcDecrypt(encAB, skB))
            hAB = SHA256.new(pickle.dumps((kAB, tAB)))
            verifierAB = PKCS1_v1_5.new(RSA.importKey(pkA))
            if verifierAB.verify(hAB, sigAB):
                output('Recipient: Key Exchange Complete')
            else:
                output('Recipient: Could not verify signature on shared key')
        else:
            output('Recipient: Could not verify certificates')
class roleS(process):
    def setup(skS, pkS, clientKeys):
        Random.atfork()
    def run():
        await(some(received(('msg01', A, B), from_ = A)))
        pkA = [x for (p, x) in clientKeys if p == A].pop()
        pkB = [x for (p, x) in clientKeys if p == B].pop()
        tA = tB = time.time()
        hA = SHA256.new(pickle.dumps((A, pkA, tA)))
        hB = SHA256.new(pickle.dumps((B, pkB, tB)))
        signer = PKCS1_v1_5.new(RSA.importKey(skS))
        sigA = signer.sign(hA)
        sigB = signer.sign(hB)
        send(('msg02', (A, pkA, tA, sigA), (B, pkB, tB, sigB)), to = A)
        output('Server: Certificates Sent')
def main():
    skS = RSA.generate(2048)
    pkS = skS.publickey()
    skA = RSA.generate(2048)
    pkA = skA.publickey()
    skB = RSA.generate(2048)
    pkB = skB.publickey()
    S = new(roleS)
    B = new(roleB, (S, skB.exportKey(), pkB.exportKey(), pkS.exportKey()))
    A = new(roleA, (B, S, skA.exportKey(), pkA.exportKey(), pkS.exportKey()))
    setup(S, (skS.exportKey(), pkS.exportKey(), [(A, pkA.exportKey()), (B, pkB.exportKey())]))
    start(S)
    start(B)
    start(A)
