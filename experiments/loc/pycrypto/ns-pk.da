import pickle
from Crypto import Random
from Crypto.Random import random
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad
def pcEncrypt(data, key):
    pubk = RSA.importKey(key)
    cipher = PKCS1_OAEP.new(pubk)
    try:
        ct = cipher.encrypt(data)
    except ValueError:
        #print('********hybrid encrypt', flush = True)
        sharedk = Random.new().read(32)
        iv = Random.new().read(AES.block_size)
        sharedCipher = AES.new(sharedk, AES.MODE_CBC, iv)
        dataCT = sharedCipher.encrypt(pad(data))
        keyCT = cipher.encrypt(sharedk)
        ct = keyCT + iv + dataCT
    return ct
def pcDecrypt(ct, key):
    privk = RSA.importKey(key)
    cipher = PKCS1_OAEP.new(privk)
    if len(ct) > (2048 // 8): #RSA keysize, PyCrypto's size method cannot be trusted.
        #print('*******hybrid decrypt', flush = True)
        sharedk = cipher.decrypt(ct[:256])
        iv = ct[256:272]
        sharedCipher = AES.new(sharedk, AES.MODE_CBC, iv)
        data = unpad(sharedCipher.decrypt(ct[272:]))
    else:
        data = cipher.decrypt(ct)
    return data
class roleS (process):
    def setup(skS, clientKeys):
        Random.atfork()
    def run():
        await(False)
    def receive(msg=('msg1', (I, R)), from_ = I):
        pkR = [x for (p, x) in clientKeys if p == R].pop()
        hR = SHA256.new(pickle.dumps((R, pkR)))
        signer = PKCS1_v1_5.new(RSA.importKey(skS))
        sigR = signer.sign(hR)
        send(('msg2', ((R, pkR), sigR)), to = I)
    def receive(msg=('msg4', (R, I)), from_ = IR):
        pkI = [x for (p, x) in clientKeys if p == I].pop()
        hI = SHA256.new(pickle.dumps((I, pkI)))
        signer = PKCS1_v1_5.new(RSA.importKey(skS))
        sigI = signer.sign(hI)
        send(('msg5', ((I, pkI), sigI)), to = R)
class roleI (process):
    def setup(skI, S, pkS, R):
        Random.atfork()
    def run():
        send(('msg1', (self, R)), to = S)
        await(some(received(('msg2', ((_R, pkR), sigS)), from_ = _S)))
        hS = SHA256.new(pickle.dumps((R, pkR)))
        verifier = PKCS1_v1_5.new(RSA.importKey(pkS))
        if verifier.verify(hS, sigS):
            nI = random.StrongRandom().getrandbits(128)
            send(('msg3', pcEncrypt(pickle.dumps((nI, self)), pkR)), to = R)
            await(some(received(('msg6', encRI), from_ = _R)))
            if some((_nI, nR, _R) in [pickle.loads(pcDecrypt(encRI, skI))]):
                send(('msg7', pcEncrypt(pickle.dumps(nR), pkR)), to = R)
                output('I authenticated R')
class roleR (process):
    def setup(skR, S, pkS):
        Random.atfork()
    def run():
        await(False)
    def receive(msg=('msg3', encIR), from_ = I):
        if some((nI, _I) in [pickle.loads(pcDecrypt(encIR, skR))]):
            send(('msg4', (self, I)), to = S)
            await(some(received(('msg5', ((_I, pkI), sigS)), from_ = _S)))
            hS = SHA256.new(pickle.dumps((I, pkI)))
            verifier = PKCS1_v1_5.new(RSA.importKey(pkS))
            if verifier.verify(hS, sigS):
                nR = random.StrongRandom().getrandbits(128)
                send(('msg6', pcEncrypt(pickle.dumps((nI, nR, self)), pkI)), to = I)
                await(some(received(('msg7', encIR2), from_ = _I)))
                if pickle.loads(pcDecrypt(encIR2, skR)) == nR:
                    output('R authenticated I')
def main():
    skS = RSA.generate(2048)
    pkS = skS.publickey()
    skI = RSA.generate(2048)
    pkI = skI.publickey()
    skR = RSA.generate(2048)
    pkR = skR.publickey()
    S = new(roleS)
    R = new(roleR, (skR.exportKey(), S, pkS.exportKey()))
    I = new(roleI, (skI.exportKey(), S, pkS.exportKey(), R))
    setup(S, (skS.exportKey(), [(I, pkI.exportKey()), (R, pkR.exportKey())]))
    start(S)
    start(R)
    start(I)
