from sa.secalgo import *
configure(verify_returns = 'bool')
class RoleI (process):
    def setup(SK_I, PK_I, R, PK_R, cert_I, pk_sig_T):
        self.I = self
    def run():
        dh_x, dh_X, _, _ = keygen('dh', dh_p = PK_I[2], dh_g = PK_I[1])
        send(('msg1', dh_X, sign((dh_X, R), key = SK_I), cert_I), to = R)
        await(some(received(('msg2', dh_Y, k, m, cert_R), from_ = R)))
        if verify(((R, PK_R), cert_R), pk_sig_T) != None:
            if verify(((dh_X, dh_Y, k, I), m), PK_R[0]) != None:
                K_IR = key_derivation(dh_Y, dh_x, PK_I[2])
                send(('msg3', BitGen(K_IR)), to = R)
                output('I - Authenticated Exchange of Key Material Complete')
class RoleR (process):
    def setup(SK_R, PK_R, PK_I, cert_R, pk_sig_T):
        self.R = self
    def run():
        if await(False): pass
        elif timeout(10): pass
    def receive(msg=('msg1', dh_X, m, cert_I), from_ = I):
        dh_y, dh_Y, _, _ = keygen('dh', dh_p = PK_I[2], dh_g = PK_I[1])
        if verify(((I, PK_I), cert_I), pk_sig_T) != None:
            if verify(((dh_X, R), m), PK_I[0]) != None:
                from Crypto.Random.random import randint
                k = randint(1, 100) #k supposed to be bitstring
                send(('msg2', dh_Y, k, sign((dh_X, dh_Y, k, I), key = SK_R), cert_R), to = I)
                K_IR = key_derivation(dh_X, dh_y, PK_I[2])
                await(some(received(('msg3', m2), from_ = I)))
                if BitGen(K_IR) == m2:
                    output('R - Authenticated Exchange of Key Material Complete')
def main():
    sk_sig_I, pk_sig_I = keygen('public')
    sk_sig_R, pk_sig_R = keygen('public')
    sk_sig_T, pk_sig_T = keygen('public')
    dh_grp_I = keygen('dh', 1, dh_mod_size = 128)
    dh_grp_R = keygen('dh', 1, dh_mod_size = 128)
    SK_I = sk_sig_I
    SK_R = sk_sig_R
    PK_I = (pk_sig_I, dh_grp_I[2], dh_grp_I[3])
    PK_R = (pk_sig_R, dh_grp_R[2], dh_grp_R[3])
    R = new(RoleR)
    I = new(RoleI)
    cert_I = sign((I, PK_I), sk_sig_T)
    cert_R = sign((R, PK_R), sk_sig_T)
    setup(R, (SK_R, PK_R, PK_I, cert_R, pk_sig_T))
    setup(I, (SK_I, PK_I, R, PK_R, cert_I, pk_sig_T))
    start(R)
    start(I)
def BitGen(x):
    import random
    random.seed(x)
    return random.getrandbits(256)
def key_derivation(public, private, mod_p):
    shared_secret = pow(public, private, mod_p)
    ss_length_bits = shared_secret.bit_length()
    ss_length_bytes = ss_length_bits // 8
    if ss_length_bits % 8 != 0:
        ss_length_bytes += 1
    ss_as_bytes = shared_secret.to_bytes(ss_length_bytes, byteorder = 'little')
    from Crypto.Hash import SHA256
    new_key = SHA256.new(ss_as_bytes).digest()
    return new_key
