"""
Needham-Schroeder Symmetric Key Key Exhange Protocol
Written by Christopher Kane

Original Source:
R. Needham and M. Schroeder. "Authentication revisited". 
Operating Systems Review, 21(7), January 1987.

Immediate Source:
Security Protocol Open Repository
http://www.lsv.fr/Software/spore/nssk_amended.html

Protocol Diagram:
  (1) I -> R : A
  (2) R -> I : enc((I, N1_R), K_RS)
  (3) I -> S : (I, R, N_I, enc((I, N1_R), K_RS))
  (4) S -> I : enc((N_I, K_IR, R, enc((K_IR, N1_R, I), K_RS)), K_IS)
  (5) I -> R : enc((K_IR, N1_R, I), K_RS)
  (6) R -> I : enc(N2_R, K_IR)
  (7) I -> R : enc(N2_R - 1, K_IR)
"""
# The corrected version of the Needham-Schroeder Symmetric Key key exchange
# protocol differs from the uncorrected version in several ways.

# The corrected version adds two new messages to the front of the protocol.
# Instead of contacting the keyserver first, the initiator first contacts the
# receiver to let it know it wishes to establish a new session key. The receiver
# responds with a message containing a fresh nonce encrypted for the keyserver.

# The rest of the messages in the corrected protocol are all very similar (and
# in the case of the last two, identical) to the corresponding messages from
# the uncorrected protocol. The only difference is the presence of the new
# encrypted nonoce passed from the receiver to the keyserver and back
# (mediated by messages to the initiator).

# The purpose of this new nonce is to prevent adversaries from replaying old
# messages from the keyserver to the receiver containing old compromised keys.
# Doing so would allow for man-in-the-middle attacks against the protocol.

# The replayed message is the third message from the uncorrected protocol:
#    (3) I -> R : enc((K_IR, I), K_RS)
# The receiver will trust this message becuase it is encrypted with the key
# it shares with the trusted key server. But, an adversary who has compromised
# the shared key K_IR, can replay this message and trick the receiver into
# using the compromised key by replaying this message.

# This attack is prevented by the change to the corresponding message in the
# corrected NS-SK protocol, Msg 5:
#    (5) I -> R : enc((K_IR, N1_R, I), K_RS)
# The presence of the fresh nonce that the receiver just sent to the keyserver
# through Msg 1 and Msg 2 assures the receiver that this is a new key sent in
# response to its agreement to set up a new shared key with the initiator.
# Attempts to replay a version of this message from earlier interactions with
# the keyserver and the initiator will not have the new nonce, and so will be
# rejected.
import time, json, sys
from sa.secalgo import *

testdata = b''
with open('testdata.sac', 'rb') as f:
    testdata = f.read()

class RoleS (process):
    def setup(kIS, kRS, loops, testsize):
        at_fork()
        self.start_time = 0

    def run():
        self.start_time = time.process_time()
        await(False)

    # Msg3 of the Corrected version of NS-SK contains an extra item, which is
    # an identifier for the initator and a nonce encrypted by the receiver
    # using the key it shares with the keyserver.
    def receive(msg=('msg3', i, (I, R, nI, encRS)), from_ = I):
        # The keyserver decrypts the identifier and nonce sent to it by the
        # receiver (by way of the initiator).
        # The keyserver makes sure that the decrypted identifier corresponds to
        # the identifier of the initiator that sent the keyserver the current
        # request. This assures the keyserver that the receiver wants to
        # perform a key exchange with this initiator.
        if some((_I, nR1) in [decrypt(encRS, key = kRS)]):
            kIR = keygen('shared')
            kIR = testdata[:testsize]
            send(('msg4', i, encrypt((nI, kIR, R, encrypt((kIR, nR1, I), key = kRS)),
                                  key = kIS)), to = I)

        if i == (loops - 1):
            print(json.dumps(['ns-sk_fixed', 'RoleS', self.start_time,
                              time.process_time(), loops]))
            exit()

class RoleI (process):
    def setup(S, kIS, R, loops):
        at_fork()

    def run():
        start_time = time.process_time()
        for i in range(loops):
            result = ns_sk(i)
        print(json.dumps(['ns-sk_fixed', 'RoleI', start_time, time.process_time(), loops]))

    def ns_sk(i):
        # Msg 1 of the corrected version of NS-SK is sent by the initiator to
        # the receiver containing just the process id of the initiator.
        send(('msg1', i, self), to = R)

        # Msg 2 of the corrected version of NS-SK is the response from the
        # receiver containing a tuple encrypted for the keyserver containing
        # the process id of the initiator (included in Msg 1) and a nonce.
        await(some(received(('msg2', _i, encRS), from_ = _R)))

        # Msg 3 of the corrected version of NS-SK is sent by the initiator to
        # the keyserver. This differs from the first message of the uncorrected
        # protocol by containing the encrypted tuple sent by the receiver.
        nI = nonce()
        send(('msg3', i, (self, R, nI, encRS)), to = S)

        # Msg 4 of the corrected version of NS-SK is identical (from the
        # perspective of the initiator) to the second message of the
        # uncorrected protocol. The only difference is the presence of the
        # nonce in the encrypted tuple being passed back to the receiver.
        await(some(received(('msg4', _i, encIS), from_ = _S),
                   has = some((_nI, kIR, _R, encSR) in [decrypt(encIS, key = kIS)])))
        kIRu = keygen('shared', key_mat = kIR[:32])

        # Msg 5 of the corrected version of NS-SK is identical (again, from the
        # perspective of the initiator) to the third message of the uncorrected
        # protocol. It simply passes an encrypted tuple from the keyserver to
        # receiver.
        send(('msg5', i, encSR), to = R)

        # Msg 6 of the corrected version of NS-SK is identical to the fourth
        # message of the uncorrected version. It contains a fresh nonce sent
        # by the receiver encrypted with the new session key (K_IR).
        # The fresh nonce encrypted with the session key proves that the
        # receiver is now in possession of the new session key to the initator.
        await(some(received(('msg6', _i, encRI), from_ = _R)))
        nR = decrypt(encRI, key = kIRu)

        # Msg 7 of the corrected version of NS-SK is identical to the fifth
        # message of the uncorrected protocol. The initiator reduces the value
        # of the nonce by 1, and then sends the modified nonce back to the
        # receiver encrypted with the new session key. This is done so the
        # initiator can prove to the receiver that it is also in possession of
        # the new session key.
        send(('msg7', i, encrypt((nR - 1), key = kIRu)), to = R)
        return i

class RoleR (process):
    def setup(S, kRS, loops):
        at_fork()
        self.start_time = 0
    
    def run():
        self.start_time = time.process_time()
        await(False)

    # Msg 1 of the corrected version does not appear in the uncorrected
    # protocol. The initiator sends its process id to the receiver.
    def receive(msg=('msg1', i, I), from_ = I2):
        # The receiver first checks that the process id in the message matches
        # the source of the message given by the from_ field.
        if I == I2:
            
            # If so, then the receiver generates a nonce that will be encrypted
            # for the keyserver. The receiver will use this nonce to ensure
            # that the response from the keyserver containing the new session
            # key is fresh--that it is not an attempt to replay an old session
            # key response because an old response will not contain the new
            # nonce.
            nR1 = nonce()

            # Msg 2 of the corrected NS-SK does not appear in the uncorrected
            # version. It contains the process id of the initiator sent in the
            # first message and the new nonce encrypted with the key the
            # receiver shares with the keyserver.
            send(('msg2', i, encrypt((I, nR1), key = kRS)), to = I)

            # Msg 5 of the corrected NS-SK is almost the same as the third
            # message of the uncorrected protocol. It contains a tuple of
            # the process id of the initiator, the nonce sent to the keyserver
            # and the new session key encrypted with the key shared by the
            # receiver and the keyserver
            # The value of the process id and the nonce must be checked against
            # the saved valued before the protocol can proceed.
            await(some(received(('msg5', _i, encSR), from_ = _I),
                       has = some((kIR, _nR1, _I) in [decrypt(encSR, key = kRS)])))
            kIRu = keygen('shared', key_mat = kIR[:32])
            # The receiver now generates a new nonce it can use to assure
            # itself and the initiator that each is in possession of the new
            # session key.
            nR2 = nonce()

            # Msg 6 of the corrected NS-SK is identical to the fourth message
            # of the uncorrected protocol. It contains just the new nonce
            # encrypted with the new session key. It proves to the initiator
            # that the receiver possesses the new session key.
            send(('msg6', i, encrypt(nR2, key = kIRu)), to = I)

            # Msg 7 of the corrected NS-SK is identical to the fifth message of
            # the uncorrected protocol. It contains a modified nonce encrypted
            # with the new session key. It proves to the receiver that the
            # initiator possesses the new session key.
            await(some(received(('msg7', _i, encIR), from_ = _I),
                       has = ((nR2 - 1) == decrypt(encIR, key = kIRu))))

            if i == (loops - 1):
                print(json.dumps(['ns-sk_fixed', 'RoleR', self.start_time,
                                  time.process_time(), loops]))
                exit()

def main():
    loops = int(sys.argv[1]) if len(sys.argv) > 1 else 1000
    testsize = int(sys.argv[2]) if len(sys.argv) > 2 else 256
    kIS = keygen('shared')
    kRS = keygen('shared')
    S = new(RoleS, (kIS, kRS, loops, testsize))
    R = new(RoleR, (S, kRS, loops))
    I = new(RoleI, (S, kIS, R, loops))
    start(S)
    start(R)
    start(I)
