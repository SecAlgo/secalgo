"""
Denning-Sacco Public Key Key Exchange Protocols
Written by Christopher Kane

Original Source:
Dorothy Denning and Giovanni Sacco, "Timestamps in Key Distribution Protocols",
Communications of the ACM, v.24.8, Aug. 1981, p. 533-536.

Protocol Diagram:
  (1) A -> S: (A, B)
  (2) S -> A: (CA, CB)
  (3) A -> B: (CA, CB, enc(sign((K, T), SK_A), PK_B))

CA and CB are certificates containing the name and public key of A and B
respecitively signed by the key server S. Certificates look like this:
  CX == (X, PK_X, T, sign((X, PK_X, T), SK_S))
T is a timestamp. Denning and Sacco give no details concerning the format of
the timestamp, and, though they discuss how the timestamp can be validated,
they do not explain how this validation should be incorporated into the
protocol.
"""

import sys, time, json
from sa.secalgo import *
configure(verify_returns = 'bool')


class roleA(process):
    def setup(B, S, sk_A, pk_A, pk_S, loops):
        pass

    def run():
        start_time = time.process_time()
        for i in range(loops):
            result = ds_pk_a(i)
            await(result == i)
        print(json.dumps(['ds-pk', 'roleA', start_time, time.process_time(), loops]), flush = True)

            
    def ds_pk_a(i):
        send(('msg01', i, self, B), to = S)
        await(some(received(('msg02', _i, (A, _pk_A, t_A, sig_A),
                             (_B, pk_B, t_B, sig_B)), from_ = S),
                   has = (A == self)))
        if (verify(((A, pk_A, t_A), sig_A), pk_S) and
            verify(((B, pk_B, t_B), sig_B), pk_S)):
            k_AB = keygen('shared')
            t_AB = time.time()
            send(('msg03', i, (A, pk_A, t_A, sig_A), (B, pk_B, t_B, sig_B),
                  encrypt(((k_AB, t_AB), sign((k_AB, t_AB), sk_A)), pk_B)),
                 to = B)
            output('Initiator: Key Exchange Complete', '(', i, ')')
        else:
            output('Initiator: Could not verify certificates', '(', i, ')')
        return i

class roleB(process):
    def setup(S, sk_B, pk_B, pk_S, loops):
        pass

    def run():
        start_time = time.process_time()
        for i in range(loops):
            result = ds_pk_b(i)
            await(result == i)
        print(json.dumps(['ds-pk', 'roleB', start_time, time.process_time(), loops]), flush = True)

    def ds_pk_b(i):
        await(some(received(('msg03', _i, (A, pk_A, t_A, sig_A),
                             (B, _pk_B, t_B, sig_B),
                             encrypted_key), from_ = A), has = (B == self)))
        if (verify(((A, pk_A, t_A), sig_A), pk_S) and
            verify(((B, pk_B, t_B), sig_B), pk_S)):
            (k_AB, t_AB), sig_AB = decrypt(encrypted_key, sk_B)
            if verify(((k_AB, t_AB), sig_AB), pk_A):
                output('Recipient: Key Exchange Complete', '(', i, ')')
            else:
                output('Recipient: Could not verify signature on shared key', '(', i, ')')
        else:
            output('Recipient: Could not verify certificates', '(', i, ')')
        return i

class roleS(process):
    def setup(sk_S, pk_S, client_keys, loops):
        pass

    def run():
        start_time = time.process_time()
        for i in range(loops):
            result = ds_pk_s(i)
            await(result == i)
        print(json.dumps(['ds-pk', 'roleS', start_time, time.process_time(), loops]), flush = True)


    def ds_pk_s(i):
        await(some(received(('msg01', _i, A, B), from_ = A)))
        pk_A = [x for (p, x) in client_keys if p == A].pop()
        pk_B = [x for (p, x) in client_keys if p == B].pop()
        t_A = t_B = time.time()
        send(('msg02', i, (A, pk_A, t_A, sign((A, pk_A, t_A), sk_S)),
              (B, pk_B, t_B, sign((B, pk_B, t_B), sk_S))), to = A)
        output('Server: Certificates Sent', '(', i, ')')
        return i

def main():
    loops = int(sys.argv[1]) if len(sys.argv) > 1 else 1000
    sk_S, pk_S = keygen('public')
    sk_A, pk_A = keygen('public')
    sk_B, pk_B = keygen('public')
    S = new(roleS)
    B = new(roleB, (S, sk_B, pk_B, pk_S, loops))
    A = new(roleA, (B, S, sk_A, pk_A, pk_S, loops))
    setup(S, (sk_S, pk_S, [(A, pk_A), (B, pk_B)], loops))
    start(S)
    start(B)
    start(A)
