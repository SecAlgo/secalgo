import sys
import pickle
import random
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.PublicKey import RSA
from Crypto.PublicKey.RSA import _RSAobj
from Crypto.Hash import SHA256
from Crypto import Random

#Definition of High-Level Encryption/Authentication Methods

def gen_k():
    return RSA.generate(2048)

def gen_pk(k):
    return k.publickey()

def gen_symk():
    return Random.new().read(32)

def encrypt(data, key):
    data_flag = (0).to_bytes(1, byteorder = 'little')
    if not isinstance(data, bytes):
        data = pickle.dumps(data)
        data_flag = (1).to_bytes(1, byteorder = 'little')
    if isinstance(key, _RSAobj):
        if len(data > 256):
            blergh = data_flag + (key.encrypt(data[0:256], '')[0] + key.encrypt(data[256:], '')[0], )
            return blergh
        return data_flag + key.encrypt(data, '')
    pre = Random.new().read(8)
    ctr = Counter.new(64, prefix = pre)
    crypter = AES.new(key, AES.MODE_CTR, counter = ctr)
    return data_flag + pre + crypter.encrypt(data)

def decrypt(data, key):
    data_flag = data[0]
    if isinstance(key, _RSAobj):
        if len(data[0]) > 256:
            blergh = ((key.decrypt(data[0][1:257], )) + key.decrypt(data[0][257:], ))
            if data_flag == 1:
                blergh = pickle.loads(blergh)
            return blergh
        if data_flag == 1:
            return pickle.loads(key.decrypt(data))
        return key.decrypt(data)
    pre = data[1:9]
    ctr = Counter.new(64, prefix = pre)
    crypter = AES.new(key, AES.MODE_CTR, counter = ctr)
    if data_flag == 1:
        return pickle.loads(crypter.decrypt(data[9:]))
    return crypter.decrypt(data[9:])

def sign(data, key):
    sig = key.sign(SHA256.new(data).digest(), '')
    result = (data, sig[0].to_bytes(((sig[0].bit_length() // 8) + 1), byteorder = 'little'))
    return pickle.dumps(result)

#returns None when verification fails
def checksign(data, key):
    unp_data = pickle.loads(data)
    sig = (int.from_bytes(unp_data[1], byteorder = 'little'), )
    verdict = key.verify(SHA256.new(unp_data[0]).digest(), sig)
    if verdict:
        return unp_data[0]
    else:
        return None

#End of High-Level Encryption/Authentication Methods

#Misc Global Methods

def needed():
    if random.random() < 0.25:
        return True
    else:
        return False

#End Misc Global Methods

"""
This is the key-generation server. The initiator of the Needham-Schroeder 
protocol ask thes the key-gen server to create a session key that will be
used to communicate with the recipient of the NS protocol. Two copies of
that key are encrypted, one for the initiator and one for the recipeient
and then packaged together and returned to the initiator.

The initiator is responsible for passing the recipients encrypted session key
to them.

All possible participants in the NS protocol share a key with the key-gen 
server, which is used to encrypt session key packages for that specific client.

1. The server-client keys are generated and distributed in main as part of the
setup for each kind of process.

2. All the key-gen server behavior is defined in its receive handler.
"""
class kg_server (process):
    def setup(keys: dict()):
        pass
        
    def run():
        output('key server started')
        await(False)

    def receive(msg=('get_key', p, cid, nonce), from_ = client):
        shared_key = Random.new().read(32)
        package_b = encrypt((shared_key, client), self.keys[p])
        package_a = encrypt((nonce, shared_key, p, package_b), self.keys[client])
        send(('re_get_key', cid, package_a), to = client)

"""
Protocol steps -
1. A process, I, initiating the NS protocol first chooses a recipient process,
   R. 

2. I sends a request to the key-gen server for a session key it can use to 
   securely communicate with R. (get-key)

3. The key-gen server responds by generating a new key, and then sending back
   two encrypted copies of that key, one encrypted for I and the other 
   encrypted for R. (re_get_key)

4. I extracts its copy of the key from the package sent by the key-gen server.

5. I forwards the copy of the key encrypted for R to R. (ns-key)

6. R extracts its copy of the session key and uses it to encrypt a nonce and
   send it to I. (ns-reply)

7. I decrypts the nonce, modifies it (subtracting 1 is a common option), 
   re-encrypts it, and then sends it back to R.

8. R decrypts the modified nonce, and checks the value against the nonce it
   generated.

At the end of this procedure both I and R possess a shared session key and have
proven to each other that each is in possession of that key.

Implementation Features -

I added a message passing sequence at the end.

All of the NS initator's behavior is defined in the ns() method (and the 
get_key() method called from within the ns() method.

All of the NS recipients behavior is defined in a receive handler (This could 
be split up among several receive handlers).

The number of processes that can take part in the NS protocol can be determined
through a command line argument. The default number is 10.
"""
class P (process):
    def setup(s, server_key, kg_p):
        self.counter = 0

    def run():
        output('started')
        if needed():
            b = random.choice(tuple(s))
            s = ns(b)
            output(s)
            await(False)
        else:
            await(False)

    #This is still the bad implementation of gen_cid(); I will fix it soon.
    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)

    def get_key_package(p):
        cid = self.gen_cid()
        nonce = random.getrandbits(128)
        send(('get_key', p, cid, nonce), to = self.kg_p)
        await(some(received(('re_get_key', _cid, c_package_a))))
        key_package = decrypt(c_package_a, self.server_key)
        if nonce == key_package[0] and p == key_package[2]:
            return key_package
        else:
            output('ERROR: Received wrong key package!')
            return None

    def ns(b):
        output('NS initiated from', self.id, 'to', b)
        package_a = get_key_package(b)
        key_ab, package_b = package_a[1], package_a[3]
        cid = self.gen_cid()
        send(('ns-key', cid, package_b), to = b)
        await(some(received(('ns-reply', _cid, c_nonce_ba), from_ = b)))
        nonce_ba = decrypt(c_nonce_ba, key_ab)
        send(('ns-reply2', cid, encrypt((nonce_ba - 1), key_ab)), to = b)
        await(some(received(('msg', _cid, m), from_ = b)))
        return decrypt(m, key_ab)

    def receive(msg=('ns-key', cid, c_package_b), from_ = b):
        key_ab, initiator = decrypt(c_package_b, self.server_key)
        nonce_ba = random.getrandbits(128)
        if initiator == b:
            send(('ns-reply', cid, encrypt(nonce_ba, key_ab)), to = b)
        await(some(received(('ns-reply2', _cid, c_nonce_mod), from_ = b)))
        if decrypt(c_nonce_mod, key_ab) == (nonce_ba - 1):
            s = 'secret'
            send(('msg', cid, encrypt(s, key_ab)), to = b)
        else:
            output('ERROR: Key package not for sender!')

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    ps = new(P, num = n)
    kg_p = new(kg_server)
    new_keys = dict()
    for p in ps:
        new_key = Random.new().read(32)
        new_keys[p] = new_key
        setup(p, ((ps - {p}), new_key, kg_p))
    setup(kg_p, (new_keys, ))
    start(kg_p)
    start(ps)
