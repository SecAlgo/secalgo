import sys
import random
import json
from charm.core.engine.util import objectToBytes, bytesToObject
from charm.core.math.pairing import hashPair as extractor
from charm.toolbox.symcrypto import SymmetricCryptoAbstraction
from charm.toolbox.pairinggroup import PairingGroup, GT
from charm.toolbox.integergroup import IntegerGroup
from charm.toolbox.conversion import Conversion
from charm.toolbox.securerandom import OpenSSLRand
from charm.schemes.pkenc.pkenc_rsa import RSA, RSA_Enc, RSA_Sig

RSA_KEY_LENGTH_BYTES = 128

#Misc Global Methods

def needed():
    if random.random() < 0.25:
        return True
    else:
        return False
# end neeed()

#End Misc Global Methods        

class pk_server(process):
    def setup():
        self.public_keys = dict()
    #end setup()

    def run():
        output('pks started')
        await(False)
    #end run()

    def receive(msg=('set_pk', p, k, cid), from_ = client):
        self.public_keys[p] = k
        send(('re_set_pk', cid), to = client)
    #end receive(set_pk)

    def receive(msg=('get_pk', p, cid), from_ = client):
        await(p in self.public_keys.keys())
        send(('re_get_pk', self.public_keys[p], cid), to = client)
    #end receive(get_pk)
#end class pk_server

class Initiator(process):
    def setup(rs, pk_p, testing, test_i, test_r):
        self.public_key, self.secret_key = RSA().keygen(1024)
        self.counter = 0
    #end setup()

    def run():
        output('initiator started')
        set_pk(self.id, self.public_key)
        if needed() and not testing:
            b = random.choice(tuple(rs))
            s = ds(b)
            output(s)
        if testing and test_i:
            test_s = ds(test_r.pop())
            output(test_s)
        await(False)
    #end run()

    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)
    #end gen_cid()

    def set_pk(p, k):
        cid = self.gen_cid()
        send(('set_pk', p, objectToBytes(k, IntegerGroup()), cid), to = self.pk_p)
        await(some(received(('re_set_pk', _cid))))
    #end set_pk()

    def get_pk(p):
        cid = self.gen_cid()
        send(('get_pk', p, cid), to = self.pk_p)
        await(some(received(('re_get_pk', k, _cid))))
        return bytesToObject(k, IntegerGroup())
    #end get_pk

    def ds(r):
        output('DS initiated from', self.id, 'to', r)
        pkR = get_pk(r)
        k = PairingGroup('SS512').random(GT)
        key_sig = RSA_Sig().sign(self.secret_key, k)

        serial_k = objectToBytes(k, PairingGroup('SS512'))
        serial_key_sig = objectToBytes(Conversion.OS2IP(key_sig), IntegerGroup())

        c_key_sig = []
        sig_frags = (len(serial_key_sig) // RSA_KEY_LENGTH_BYTES) + 1
        for i in range(sig_frags):
            c_key_sig.append(RSA_Enc().encrypt(pkR, serial_key_sig[(i*RSA_KEY_LENGTH_BYTES):((i+1)*RSA_KEY_LENGTH_BYTES)]))

        c_k = []   
        k_frags = (len(serial_k) // RSA_KEY_LENGTH_BYTES) + 1
        for j in range(k_frags):
            c_k.append(RSA_Enc().encrypt(pkR, serial_k[(i*RSA_KEY_LENGTH_BYTES):((i+1)*RSA_KEY_LENGTH_BYTES)]))

        serial_encrypted_k_and_sig = objectToBytes([c_k, c_key_sig], IntegerGroup())

        send(('ds-key', serial_encrypted_k_and_sig), to = r)
        await(some(received(('msg', m), from_ = r)))
        decrypter = SymmetricCryptoAbstraction(extractor(k))
        return decrypter.decrypt(m)
    #end ds()
#end class Initiator

class Recipient(process):
    def setup(pk_p):
        self.public_key, self.secret_key = RSA().keygen(1024)
        self.counter = 0
    #end setup()

    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)
    #end gen_cid()

    def run():
        output('recipient started')
        set_pk(self.id, self.public_key)
        await(False)
    #end run()

    def set_pk(p, k):
        cid = self.gen_cid()
        send(('set_pk', p, objectToBytes(k, IntegerGroup()), cid), to = self.pk_p)
        await(some(received(('re_set_pk', _cid))))
    #end set_pk()

    def get_pk(p):
        cid = self.gen_cid()
        send(('get_pk', p, cid), to = self.pk_p)
        await(some(received(('re_get_pk', k, _cid))))
        return bytesToObject(k, IntegerGroup())
    #end get_pk

    def receive(msg=('ds-key', m), from_ = i):
        pkI = get_pk(i)
        c_k, c_key_sig = bytesToObject(m, IntegerGroup())

        serial_k = b''
        for k_frag in c_k:
            serial_k += RSA_Enc().decrypt(self.public_key, self.secret_key, k_frag)


        k = bytesToObject(serial_k, PairingGroup('SS512'))

        serial_key_sig = b''
        for sig_frag in c_key_sig:
            serial_key_sig += RSA_Enc().decrypt(self.public_key, self.secret_key, sig_frag)
        key_sig = Conversion.IP2OS(bytesToObject(serial_key_sig, IntegerGroup()))

        verdict = RSA_Sig().verify(pkI, k, key_sig)
        if verdict:
            s = "secret"
            encrypter = SymmetricCryptoAbstraction(extractor(k))
            send(('msg', encrypter.encrypt(s)), to = i)
        else:
            output('VERIFICATION FAILED for DS from', i, 'to', self.id)
    #end receive(ds-key)
#end class Recipient

def main():
    test_run = True if (len(sys.argv) > 1 and sys.argv[1] == 'test') else False
    n = int(sys.argv[2]) if len(sys.argv) > 2 else 10
    pk_p = new(pk_server)
    setup(pk_p, ())
    if test_run:
        i1 = new(Initiator)
        i2 = new(Initiator)
        r = new(Recipient)
        ps = i1 | i2 | r
        setup(i1, (r, pk_p, True, True, r))
        setup(i2, (r, pk_p, True, True, r))
        setup(r, (pk_p,))
        start(pk_p)
        start(ps)
    else:
        ps = new(Initiator, num = n // 2)
        rs = new(Recipient, num = n // 2)
        for p in ps:
            setup(p, (rs, pk_p, False, False, None))
        for r in rs:
            setup(r, (pk_p,))
        start(pk_p)
        start(rs)
        start(ps)
#end main()
