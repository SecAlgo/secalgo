import sys
import random
from charm.core.engine.util import objectToBytes, bytesToObject
from charm.core.math.pairing import hashPair as extractor
from charm.toolbox.symcrypto import SymmetricCryptoAbstraction
from charm.toolbox.pairinggroup import PairingGroup, GT
from charm.toolbox.integergroup import IntegerGroup
from charm.toolbox.conversion import Conversion
from charm.toolbox.securerandom import OpenSSLRand
from charm.schemes.pkenc.pkenc_rsa import RSA_Enc, RSA_Sig
from sa.Misc.da_utils import serialize_endpoint, deserialize_endpoint

#Misc Global Methods

#I am afraid I could not figure out how to implement a true once version of
#needed that would work in a distributed setting.

def needed():
    if random.random() < 0.10:
        return True
    else:
        return False
    
def print_public_keys(key_dict):
    for k, v in key_dict.items():
        print(k)
        print(v.exportKey())
#End Misc Global Methods

class pk_server (process):
    def setup():
        self.pk = dict()

    def run():
        output('pks started')
        await(False)
        #elif timeout(5):
        #print_public_keys(self.pk)

    def receive(msg=('set_pk', p, k, cid), from_ = client):
        pk[p] = k
        send(('re_set_pk', cid), to = client)

    def receive(msg=('get_pk', p, cid), from_ = client):
        await(p in self.pk.keys())
        send(('re_get_pk', self.pk[p], cid), to = client)

"""
Changes:
1. I had to move the call to set_pk() out of setup() and into run() because
set_pk() contains an await statement and await statements are not permitted
within the setup() method.

2. The await statements in set_pk() and get_pk() did nto work when the from_
class was included (that is, they never evaluated to true and all the processes
would hang. So, I remove the from_ from each.

3. I had to change the definition of get_pk inside the pk_server class in order
to prevent cases in which a process would request the public key for another
process that had not yet registered its key.

4. As it is now, each process has a 25% chance of initiating DS with some other
randomly chosen process. This has led to some problems. 

    A. If multiple processes initiate DS with the same target, then checksign 
       fails for at least one of them at the target.
    
    B. In addition, I am getting unpickling errors in some cases, though I have
       not yet identified the pattern. It may be cases in which a process
       initiates a DS connection to a target before that target has started
       run()-ing.

So, there is still some interleaving weirdness I cannot account for yet.
"""
class P (process):
    def setup(s, pk_p, testing, test_i, test_r):
        self.rsa_crypt = RSA_Enc()
        self.rsa_auth = RSA_Sig()
        self.crypt_pkA, self.crypt_skA = self.rsa_crypt.keygen(2048)
        self.auth_pkA, self.auth_skA = self.rsa_auth.keygen(1024)
        self.counter = 0
        #self.cid_gen = self.gen_cid()
        #set_pk(self.id, gen_pk(skA))

    def run():
        output('started')
        set_pk(self.id, [self.crypt_pkA, self.auth_pkA])
        if needed() and not testing:
            b = random.choice(tuple(s))
            s = ds(b)
            output(s)
        if testing and test_i:      
           test_s = ds(test_r.pop())
           output(test_s)
        await(False)

    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)

    #def gen_cid():
    #    counter = 0
    #    while True:
    #        yield (self.id, counter)
    #        counter = counter + 1

    def set_pk(p, k):
        #cid = next(self.cid_gen)
        cid = self.gen_cid()
        send(('set_pk', p, objectToBytes(k, IntegerGroup()), cid), to = self.pk_p)
        await(some(received(('re_set_pk', _cid))))
        #await(some(received(('re_set_pk', _cid), from_ = self.pk_p)))

    def get_pk(p):
        #cid = next(self.cid_gen)
        cid = self.gen_cid()
        send(('get_pk', p, cid), to = self.pk_p)
        await(some(received(('re_get_pk', k, _cid))))
        #await(some(received(('re_get_pk', k, _cid), from_ = self.pk_p)))
        return bytesToObject(k, IntegerGroup())

    def ds(b):
        output('DS Initiated from', self.id, 'to', b)

        group_object = PairingGroup('SS512')
        k = group_object.random(GT)
        
        crypt_pkB, auth_pkB = get_pk(b)
        signed_k = self.rsa_auth.sign(self.auth_skA, k)

        serial_k = objectToBytes(k, group_object)
        encrypted_k = self.rsa_crypt.encrypt(crypt_pkB, serial_k)
        encrypted_sig = self.rsa_crypt.encrypt(crypt_pkB, signed_k)

        s_encrypted_k_and_sig = objectToBytes([encrypted_k, encrypted_sig], IntegerGroup())
        send(('ds-key', s_encrypted_k_and_sig), to = b)
        await(some(received(('msg', m), from_ = b)))
        
        crypter_ab = SymmetricCryptoAbstraction(extractor(k))
        return crypter_ab.decrypt(m)
        
    def receive(msg=('ds-key', m), from_ = b):
        output('Retrieving Key for:', b)

        encrypted_k_and_sig = bytesToObject(m, IntegerGroup())
        encrypted_k, encrypted_sig = encrypted_k_and_sig
        serial_k = self.rsa_crypt.decrypt(self.crypt_pkA, self.crypt_skA, encrypted_k)
        signed_k = self.rsa_crypt.decrypt(self.crypt_pkA, self.crypt_skA, encrypted_sig)

        k = bytesToObject(serial_k, PairingGroup('SS512'))
        crypt_pkB, auth_pkB = get_pk(b)

        verdict = self.rsa_auth.verify(auth_pkB, k, signed_k)
        if verdict == True:
            s = 'secret'
            crypter_ab = SymmetricCryptoAbstraction(extractor(k))
            send(('msg', crypter_ab.encrypt(s)), to = b)
        else:
            output('VERIFICATION FAILED for DS from:', b, 'to:', self.id)

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    test_run = True if (len(sys.argv) > 2 and sys.argv[2] == 'test') else False
    pk_p = new(pk_server)
    setup(pk_p, ())
    if test_run:
        i1 = new(P, num = 1)
        i2 = new(P, num = 1)
        r = new(P, num = 1)
        ps = i1 | i2 | r
        setup(i1, (i2 | r, pk_p, True, True, r))
        setup(i2, (i1 | r, pk_p, True, True, r))
        setup(r, (i1 | i2, pk_p, True, False, r))
        start(pk_p)
        start(ps)
    else:
        ps = new(P, num = n)
        for p in ps:
            setup(p, ((ps - {p}), pk_p, False, False, None))
        start(pk_p)
        start(ps)
