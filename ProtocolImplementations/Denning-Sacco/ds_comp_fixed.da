import sys
import random
import pickle
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto.PublicKey import RSA
from Crypto.PublicKey.RSA import _RSAobj
from Crypto.Hash import SHA256
from Crypto import Random

#Definition of High-Level Encryption/Authentication Methods

def gen_k():
    return RSA.generate(2048)

def gen_pk(k):
    return k.publickey()

def gen_symk():
    return Random.new().read(32)

def encrypt(data, key):
    if isinstance(key, _RSAobj):
        if len(data) > 256:
            blergh = (key.encrypt(data[0:256], '')[0] + key.encrypt(data[256:], '')[0], )
            return blergh
        return key.encrypt(data, '')
    pre = Random.new().read(8)
    ctr = Counter.new(64, prefix = pre)
    crypter = AES.new(key, AES.MODE_CTR, counter = ctr)
    return pre + crypter.encrypt(data)

def decrypt(data, key):
    if isinstance(key, _RSAobj):
        if len(data[0]) > 256:
            blergh = key.decrypt((data[0][0:256], )) + key.decrypt((data[0][256:], ))            
            return blergh
        return key.decrypt(data)
    pre = data[0:8]
    ctr = Counter.new(64, prefix = pre)
    crypter = AES.new(key, AES.MODE_CTR, counter = ctr)
    return crypter.decrypt(data[8:])

def sign(data, key):
    sig = key.sign(SHA256.new(data).digest(), '')
    result = (data, sig[0].to_bytes(((sig[0].bit_length() // 8) + 1), 
                                    byteorder = 'little'))
    return pickle.dumps(result)

#returns None when verfication fails
def checksign(data, key):
    unp_data = pickle.loads(data)
    sig = (int.from_bytes(unp_data[1], byteorder = 'little'), )
    verdict = key.verify(SHA256.new(unp_data[0]).digest(), sig)
    if verdict:
        return unp_data[0]
    else:
        return None
               
#End of High-Level Encryption Definitions

#Misc Global Methods

#I am afraid I could not figure out how to implement a true once version of
#needed that would work in a distributed setting.

def needed():
    if random.random() < 0.25:
        return True
    else:
        return False
    
def print_public_keys(key_dict):
    for k, v in key_dict.items():
        print(k)
        print(v.exportKey())
#End Misc Global Methods

class pk_server (process):
    def setup():
        self.pk = dict()

    def run():
        output('pks started')
        await(False)
        #elif timeout(5):
        #print_public_keys(self.pk)

    def receive(msg=('set_pk', p, k, cid), from_ = client):
        pk[p] = k
        send(('re_set_pk', cid), to = client)

    def receive(msg=('get_pk', p, cid), from_ = client):
        await(p in self.pk.keys())
        send(('re_get_pk', self.pk[p], cid), to = client)

"""
Changes:
1. I had to move the call to set_pk() out of setup() and into run() because
set_pk() contains an await statement and await statements are not permitted
within the setup() method.

2. The await statements in set_pk() and get_pk() did nto work when the from_
class was included (that is, they never evaluated to true and all the processes
would hang. So, I remove the from_ from each.

3. I had to change the definition of get_pk inside the pk_server class in order
to prevent cases in which a process would request the public key for another
process that had not yet registered its key.

4. As it is now, each process has a 25% chance of initiating DS with some other
randomly chosen process. This has led to some problems. 

    A. If multiple processes initiate DS with the same target, then checksign 
       fails for at least one of them at the target.
    
    B. In addition, I am getting unpickling errors in some cases, though I have
       not yet identified the pattern. It may be cases in which a process
       initiates a DS connection to a target before that target has started
       run()-ing.

So, there is still some interleaving weirdness I cannot account for yet.
"""
class P (process):
    def setup(s, pk_p, testing, test_i, test_r):
        self.skA = gen_k()
        self.counter = 0
        #self.cid_gen = self.gen_cid()
        #set_pk(self.id, gen_pk(skA))

    def run():
        output('started')
        set_pk(self.id, gen_pk(skA))
        if needed() and not testing:
            b = random.choice(tuple(s))
            s = ds(b)
            output(s)
        if testing and test_i:      
           test_s = ds(test_r.pop())
           output(test_s)
        await(False)

    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)

    #def gen_cid():
    #    counter = 0
    #    while True:
    #        yield (self.id, counter)
    #        counter = counter + 1

    def set_pk(p, k):
        #cid = next(self.cid_gen)
        cid = self.gen_cid()
        send(('set_pk', p, k, cid), to = self.pk_p)
        #print('HEY!!!-set_pk')
        sys.stdout.flush()
        await(some(received(('re_set_pk', _cid))))
        #await(some(received(('re_set_pk', _cid), from_ = self.pk_p)))

    def get_pk(p):
        #cid = next(self.cid_gen)
        cid = self.gen_cid()
        send(('get_pk', p, cid), to = self.pk_p)
        #print('HEY!!!-get_pk')
        sys.stdout.flush()
        await(some(received(('re_get_pk', k, _cid))))
        #await(some(received(('re_get_pk', k, _cid), from_ = self.pk_p)))
        return k

    def ds(b):
        output('DS Initiated from', self.id, 'to', b)
        k = gen_symk()        
        pkB = get_pk(b)
        output('Sign Key:', skA)
        send(('ds-key', encrypt(sign(k, skA), pkB)), to = b)
        await(some(received(('msg', m), from_= b)))
        return decrypt(m, k)
        
    def receive(msg=('ds-key', m), from_ = b):
        output('Retrieving Key for:', b)
        pkB = get_pk(b)
        #output('Check Key:', pkB, '\n', pkB.exportKey(), '\n', 
        #      pkB.keydata[0], '\n', pkB.keydata[1])
        k = checksign(decrypt(m, skA), pkB)
        if k is not None:
            s = "secret"
            send(('msg', encrypt(s, k)), to = b)
        else:
            output('VERIFICATION FAILED for DS from:', b, 'to:', self.id)

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    test_run = True if (len(sys.argv) > 2 and sys.argv[2] == 'test') else False
    print(test_run)
    sys.stdout.flush()
    pk_p = new(pk_server)
    setup(pk_p, ())
    if test_run:
        i1 = new(P, num = 1)
        i2 = new(P, num = 1)
        r = new(P, num = 1)
        ps = i1 | i2 | r
        setup(i1, (i2 | r, pk_p, True, True, r))
        setup(i2, (i1 | r, pk_p, True, True, r))
        setup(r, (i1 | i2, pk_p, True, False, r))
        start(pk_p)
        start(ps)
    else:
        ps = new(P, num = n)
        for p in ps:
            setup(p, ((ps - {p}), pk_p, False, False, None))
        start(pk_p)
        start(ps)
