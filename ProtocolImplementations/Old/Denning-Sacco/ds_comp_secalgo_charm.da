import sys
import random
from charm.core.engine.util import objectToBytes, bytesToObject
from charm.toolbox.pairinggroup import PairingGroup
from charm.toolbox.integergroup import IntegerGroup
from sa.Misc.da_utils import serialize_endpoint, deserialize_endpoint
from sa.sec_algo_charm import encrypt, decrypt, sign, verify
from sa.sec_algo_charm import gen_key_pair, get_pub_key, gen_sym_key

#Misc Global Methods

#I am afraid I could not figure out how to implement a true once version of
#needed that would work in a distributed setting.
def needed():
    if random.random() < 0.10:
        return True
    else:
        return False
    
def print_public_keys(key_dict):
    for k, v in key_dict.items():
        print(k)
        print(v.exportKey())
#End Misc Global Methods

class pk_server (process):
    def setup():
        self.pk = dict()

    def run():
        output('pks started')
        await(False)
        #elif timeout(5):
        #print_public_keys(self.pk)

    def receive(msg=('set_pk', p, k, cid), from_ = client):
        pk[p] = k
        send(('re_set_pk', cid), to = client)

    def receive(msg=('get_pk', p, cid), from_ = client):
        await(p in self.pk.keys())
        send(('re_get_pk', self.pk[p], cid), to = client)

"""
Changes:
1. I had to move the call to set_pk() out of setup() and into run() because
set_pk() contains an await statement and await statements are not permitted
within the setup() method.

2. The await statements in set_pk() and get_pk() did nto work when the from_
class was included (that is, they never evaluated to true and all the processes
would hang. So, I remove the from_ from each.

3. I had to change the definition of get_pk inside the pk_server class in order
to prevent cases in which a process would request the public key for another
process that had not yet registered its key.

4. As it is now, each process has a 25% chance of initiating DS with some other
randomly chosen process.
"""
class P (process):
    def setup(s, pk_p, testing, test_i, test_r):
        self.skA = gen_key_pair()
        self.counter = 0
        #self.cid_gen = self.gen_cid()

    def run():
        output('started')
        set_pk(self.id, get_pub_key(self.skA))
        if needed() and not testing:
            b = random.choice(tuple(s))
            s = ds(b)
            output(s)
        if testing and test_i:      
           test_s = ds(test_r.pop())
           output(test_s)
        await(False)

    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)

    #def gen_cid():
    #    counter = 0
    #    while True:
    #        yield (self.id, counter)
    #        counter = counter + 1

    def set_pk(p, k):
        #cid = next(self.cid_gen)
        output('Setting pk')
        cid = self.gen_cid()
        send(('set_pk', p, objectToBytes(k, IntegerGroup()), cid), to = self.pk_p)
        await(some(received(('re_set_pk', _cid))))
        #await(some(received(('re_set_pk', _cid), from_ = self.pk_p)))

    def get_pk(p):
        output('Retrieving Key for:', p)
        #cid = next(self.cid_gen)
        cid = self.gen_cid()
        send(('get_pk', p, cid), to = self.pk_p)
        await(some(received(('re_get_pk', k, _cid))))
        #await(some(received(('re_get_pk', k, _cid), from_ = self.pk_p)))
        return bytesToObject(k, IntegerGroup())

    def ds(b):
        output('DS Initiated from', self.id, 'to', b)
        k = gen_sym_key()
        serial_k = objectToBytes(k, PairingGroup('SS512'))
        signed_k = sign(serial_k, self.skA)
        pkB = get_pk(b)
        encrypted_signed_k = encrypt(signed_k, pkB)
        s_encrypted_signed_k = objectToBytes(encrypted_signed_k, IntegerGroup())
        output('Sending Encrypted Session Key to:', b)
        send(('ds-key', s_encrypted_signed_k), to = b)
        await(some(received(('msg', m), from_ = b)))
        output('Received Encrypted Message from:', b)
        return decrypt(m, k)
        
    def receive(msg=('ds-key', m), from_ = b):
        output('Received Encrypted Session Key from:', b)
        encrypted_signed_k = bytesToObject(m, IntegerGroup())
        signed_k = decrypt(encrypted_signed_k, self.skA)
        pkB = get_pk(b)
        serial_k = verify(signed_k, pkB)
        if serial_k != None:
            k = bytesToObject(serial_k, PairingGroup('SS512'))
            s = 'secret'
            output('Sending Encrypted Message back to:', b)
            send(('msg', encrypt(s, k)), to = b)
        else:
            output('VERIFICATION FAILED for DS from:', b, 'to:', self.id)

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    test_run = True if (len(sys.argv) > 2 and sys.argv[2] == 'test') else False
    pk_p = new(pk_server)
    setup(pk_p, ())
    if test_run:
        i1 = new(P, num = 1)
        i2 = new(P, num = 1)
        r = new(P, num = 1)
        ps = i1 | i2 | r
        setup(i1, (i2 | r, pk_p, True, True, r))
        setup(i2, (i1 | r, pk_p, True, True, r))
        setup(r, (i1 | i2, pk_p, True, False, r))
        start(pk_p)
        start(ps)
    else:
        ps = new(P, num = n)
        for p in ps:
            setup(p, ((ps - {p}), pk_p, False, False, None))
        start(pk_p)
        start(ps)
