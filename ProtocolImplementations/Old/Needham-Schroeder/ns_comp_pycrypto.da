import sys
import random
import json
from Crypto.Cipher import AES
from Crypto.Util import Counter
from Crypto import Random
from Crypto.Random import random as securerandom
from sa.Misc.da_utils import serialize_endpoint, deserialize_endpoint
from sa.Misc.padding import pkcs7_pad, pkcs7_unpad

#Misc Global Methods

def needed():
    if random.random() < 0.25:
        return True
    else:
        return False
#end needed()
    
#End Misc Global Methods

"""
This is the key-generation server. The initiator of the Needham-Schroeder 
protocol ask thes the key-gen server to create a session key that will be
used to communicate with the recipient of the NS protocol. Two copies of
that key are encrypted, one for the initiator and one for the recipeient
and then packaged together and returned to the initiator.

The initiator is responsible for passing the recipients encrypted session key
to them.

All possible participants in the NS protocol share a key with the key-gen 
server, which is used to encrypt session key packages for that specific client.

1. The server-client keys are generated and distributed in main as part of the
setup for each kind of process.

2. All the key-gen server behavior is defined in its receive handler.
"""
class kg_server (process):
    def setup(keys: dict()):
        pass
    #end setup()
        
    def run():
        output('key server started')
        await(False)
    #end run()
        
    def receive(msg=('get_key', p, cid, nonce), from_ = client):
        shared_key = Random.new().read(32)
        pre_b = Random.new().read(8)
        ctr_b = Counter.new(64, prefix = pre_b)
        encrypter_b = AES.new(self.keys[p], AES.MODE_CTR, counter = ctr_b)
        package_b = [int.from_bytes(shared_key, byteorder = 'little'), serialize_endpoint(client)]
        s_package_b = json.dumps(package_b)
        cs_package_b = pre_b + encrypter_b.encrypt(s_package_b)
        pcs_package_b = pkcs7_pad(cs_package_b)
        spcs_package_b = int.from_bytes(pcs_package_b, byteorder = 'little')
        pre_a = Random.new().read(8)
        ctr_a = Counter.new(64, prefix = pre_a)
        encrypter_a = AES.new(self.keys[client], AES.MODE_CTR, counter = ctr_a)
        package_a = [nonce, int.from_bytes(shared_key, byteorder = 'little'), serialize_endpoint(p), spcs_package_b]
        s_package_a = json.dumps(package_a)
        c_package_a = pre_a + encrypter_a.encrypt(s_package_a)
        send(('re_get_key', cid, c_package_a), to = client)
    #end receive(get_key)
#end clas kg_server
"""
Protocol steps -
1. A process, I, initiating the NS protocol first chooses a recipient process,
   R. 

2. I sends a request to the key-gen server for a session key it can use to 
   securely communicate with R. (get-key)

3. The key-gen server responds by generating a new key, and then sending back
   two encrypted copies of that key, one encrypted for I and the other 
   encrypted for R. (re_get_key)

4. I extracts its copy of the key from the package sent by the key-gen server.

5. I forwards the copy of the key encrypted for R to R. (ns-key)

6. R extracts its copy of the session key and uses it to encrypt a nonce and
   send it to I. (ns-reply)

7. I decrypts the nonce, modifies it (subtracting 1 is a common option), 
   re-encrypts it, and then sends it back to R.

8. R decrypts the modified nonce, and checks the value against the nonce it
   generated.

At the end of this procedure both I and R possess a shared session key and have
proven to each other that each is in possession of that key.

Implementation Features -

I added a message passing sequence at the end.

All of the NS initator's behavior is defined in the ns() method (and the 
get_key() method called from within the ns() method.

All of the NS recipients behavior is defined in a receive handler (This could 
be split up among several receive handlers).

The number of processes that can take part in the NS protocol can be determined
through a command line argument. The default number is 10.
"""
class P (process):
    def setup(s, server_key, kg_p):
        self.counter = 0
    #end setup()
        
    def run():
        output('started')
        if needed():
            b = random.choice(tuple(s))
            s = ns(b)
            output(s)
            await(False)
        else:
            await(False)
    #end run()
            
    #This is still the bad implementation of gen_cid(); I will fix it soon.
    def gen_cid():
        self.counter += 1
        return (self.id, self.counter)
    #end gen_cid()
    
    def get_key_package(p):
        cid = self.gen_cid()
        nonce = securerandom.getrandbits(128)
        send(('get_key', p, cid, nonce), to = self.kg_p)
        await(some(received(('re_get_key', _cid, pre_c_package_a))))
        pre_a = pre_c_package_a[0:8]
        ctr_a = Counter.new(64, prefix = pre_a)
        decrypter_a = AES.new(self.server_key, AES.MODE_CTR, counter = ctr_a)
        s_key_package = decrypter_a.decrypt(pre_c_package_a[8:]).decode()
        key_package = json.loads(s_key_package)
        if nonce == key_package[0] and serialize_endpoint(p) == key_package[2]:
            return key_package
        else:
            output('ERROR: Received wrong key package!')
            return None
    #end get_key_package()
        
    def ns(b):
        output('NS initiated from', self.id, 'to', b)
        package_a = get_key_package(b)
        key_ab, spcs_package_b = (package_a[1].to_bytes(32, byteorder = 'little'), package_a[3])
        cid = self.gen_cid()
        send(('ns-key', cid, spcs_package_b), to = b)
        await(some(received(('ns-reply', _cid, pre_c_nonce_ba), from_ = b)))
        pre_ab = pre_c_nonce_ba[0:8]
        ctr_ab = Counter.new(64, prefix = pre_ab)
        crypter_ab = AES.new(key_ab, AES.MODE_CTR, counter = ctr_ab)
        nonce_ba = json.loads(crypter_ab.decrypt(pre_c_nonce_ba[8:]).decode())
        send(('ns-reply2', cid, crypter_ab.encrypt(json.dumps(nonce_ba - 1))), to = b)
        await(some(received(('msg', _cid, m), from_ = b)))
        return crypter_ab.decrypt(m).decode()
    #end ns()
    
    def receive(msg=('ns-key', cid, spcs_package_b), from_ = b):
        pcs_package_b = spcs_package_b.to_bytes(((spcs_package_b.bit_length() // 8) + 1), 
                                                byteorder = 'little')
        cs_package_b = pkcs7_unpad(pcs_package_b)
        pre_b = cs_package_b[0:8]
        ctr_b = Counter.new(64, prefix = pre_b)
        decrypter_b = AES.new(self.server_key, AES.MODE_CTR, counter = ctr_b)
        s_package_b = decrypter_b.decrypt(cs_package_b[8:]).decode()
        package_b = json.loads(s_package_b)
        key_ab, initiator = package_b[0].to_bytes(32, byteorder = 'little'), package_b[1]
        nonce_ba = securerandom.getrandbits(128)
        pre_ab = Random.new().read(8)
        ctr_ab = Counter.new(64, prefix = pre_ab)
        crypter_ab = AES.new(key_ab, AES.MODE_CTR, counter = ctr_ab)
        if initiator == serialize_endpoint(b):
            send(('ns-reply', cid, pre_ab + crypter_ab.encrypt(json.dumps(nonce_ba))), to = b)
        await(some(received(('ns-reply2', _cid, c_nonce_mod), from_ = b)))
        if json.loads(crypter_ab.decrypt(c_nonce_mod).decode()) == (nonce_ba - 1):
            s = 'secret'
            send(('msg', cid, crypter_ab.encrypt(s)), to = b)
        else:
            output('ERROR: Key package not for sender!')
    #end receive(ns-key)
            
def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    ps = new(P, num = n)
    kg_p = new(kg_server)
    new_keys = dict()
    for p in ps:
        new_key = Random.new().read(32)
        new_keys[p] = new_key
        setup(p, ((ps - {p}), new_key, kg_p))
    setup(kg_p, (new_keys, ))
    start(kg_p)
    start(ps)
#end main()
