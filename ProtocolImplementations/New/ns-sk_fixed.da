"""
Needham-Schroeder Symmetric Key Key Exhange Protocol
Written by Christopher Kane

Original Source:
R. Needham and M. Schroeder. "Authentication revisited". 
Operating Systems Review, 21(7), January 1987.

Immediate Source:
Security Protocol Open Repository
http://www.lsv.fr/Software/spore/nssk_amended.html

Protocol Diagram:
  (1) I -> R : A
  (2) R -> I : enc((I, N1_R), K_RS)
  (3) I -> S : (I, R, N_I, enc((I, N1_R), K_RS))
  (4) S -> I : enc((N_I, K_IR, R, enc((K_IR, N1_R, I), K_RS)), K_IS)
  (5) I -> R : enc((K_IR, N1_R, I), K_RS)
  (6) R -> I : enc(N2_R, K_IR)
  (7) I -> R : enc(N2_R - 1, K_IR)
"""
# The corrected version of the Needham-Schroeder Symmetric Key key exchange
# protocol differs from the uncorrected version in several ways.

# The corrected version adds two new messages to the front of the protocol.
# Instead of contacting the keyserver first, the initiator first contacts the
# receiver to let it know it wishes to establish a new session key. The receiver
# responds with a message containing a fresh nonce encrypted for the keyserver.

# The rest of the messages in the corrected protocol are all very similar (and
# in the case of the last two, identical) to the corresponding messages from
# the uncorrected protocol. The only difference is the presence of the new
# encruypted nonoce passed from the receiver to the keyserver and back
# (mediated by messages to the initiator).

# The purpose of this new nonce is to prevent adversaries from replaying old
# messages from the keyserver to the receiver containing old compromised keys.
# Doing so would allow for man-in-the-middle attacks against the protocol.

# The replayed message is the third message from the uncorrected protocol:
#    (3) I -> R : enc((K_IR, I), K_RS)
# The receiver will trust this message becuase it is encrypted with the key
# it shares with the trusted key server. But, an adversary who has compromised
# the shared key K_IR, can replay this message and trick the receiver into
# using the compromised key by replaying this message.

# This attack is prevented by the change to the corresponding message in the
# corrected NS-SK protocol, Msg 5:
#    (5) I -> R : enc((K_IR, N1_R, I), K_RS)
# The presence of the fresh nonce that the receiver just sent to the keyserver
# through Msg 1 and Msg 2 assures the receiver that this is a new key sent in
# response to its agreement to set up a new shared key with the initiator.
# Attempts to replay a version of this message from earlier interactions with
# the keyserver and the initiator will not have the new nonce, and so will be
# rejected.

from sa.secalgo import *
    
class RoleS (process):
    def setup(K_IS, K_RS):
        pass

    def run():
        await(False)

    # Msg3 of the Corrected version of NS-SK contains an extra item, which is
    # an identifier for the initator and a nonce encrypted by the receiver
    # using the key it shares with the keyserver.
    def receive(msg=('msg3', (I1, R, N_I, enc_RS)), from_ = I):
        # The keyserver decrypts the identifier and nonce sent to it by the
        # receiver (by way of the initiator).
        I2, N1_R = decrypt(enc_RS, key = K_RS)

        # The keyserver makes sure that the decrypted identifier corresponds to
        # the identifier of the initiator that sent the keyserver the current
        # request. This assures the keyserver that the receiver wants to
        # perform a key exchange with this 
        if I2 == I1:
            K_IR = keygen('shared')
            send(('msg4', encrypt((N_I, K_IR, R,
                                   encrypt((K_IR, N1_R, I2), key = K_RS)),
                                  key = K_IS)), to = I)

class RoleI (process):
    def setup(S, K_IS, R):
        pass

    def run():
        # Msg 1 of the corrected version of NS-SK is sent by the initiator to
        # the receiver containing just the process id of the initiator.
        send(('msg1', self), to = R)

        # Msg 2 of the corrected version of NS-SK is the response from the
        # receiver containing a tuple encrypted for the keyserver containing
        # the process id of the initiator (included in Msg 1) and a nonce.
        await(some(received(('msg2', enc_RS), from_ = _R)))

        # Msg 3 of the corrected version of NS-SK is sent by the initiator to
        # the keyserver. This differs from the first message of the uncorrected
        # protocol by containing the encrypted tuple sent by the receiver.
        N_I = nonce()
        send(('msg3', (self, R, N_I, enc_RS)), to = S)

        # Msg 4 of the corrected version of NS-SK is identical (from the
        # perspective of the initiator) to the second message of the
        # uncorrected protocol. The only difference is the presence of the
        # nonce in the encrypted tuple being passed back to the receiver.
        await(some(received(('msg4', enc_IS), from_ = _S),
                   has = ((decrypt(enc_IS, key = K_IS)[0] == N_I) and
                          (decrypt(enc_IS, key = K_IS)[2] == R))))
        _, K_IR, _, enc_SR = decrypt(enc_IS, key = K_IS)

        # Msg 5 of the corrected version of NS-SK is identical (again, from the
        # perspective of the initiator) to the third message of the uncorrected
        # protocol. It simply passes an encrypted tuple from the keyserver to
        # receiver.
        send(('msg5', enc_SR), to = R)

        # Msg 6 of the corrected version of NS-SK is identical to the fourth
        # message of the uncorrected version. It contains a fresh nonce sent
        # by the receiver encrypted with the new session key (K_IR).
        # The fresh nonce encrypted with the session key proves that the
        # receiver is now in possession of the new session key to the initator.
        await(some(received(('msg6', enc_RI), from_ = _R)))
        N_R = decrypt(enc_RI, key = K_IR)

        # Msg 7 of the corrected version of NS-SK is identical to the fifth
        # message of the uncorrected protocol. The initiator reduces the value
        # of the nonce by 1, and then sends the modified nonce back to the
        # receiver encrypted with the new session key. This is done so the
        # initiator can prove to the receiver that it is also in possession of
        # the new session key.
        send(('msg7', encrypt((N_R - 1), key = K_IR)), to = R)
        output('I - Key Exchange Complete')

class RoleR (process):
    def setup(S, K_RS):
        pass
    
    def run():
        await(False)

    # Msg 1 of the corrected version does not appear in the uncorrected
    # protocol. The initiator sends its process id to the receiver.
    def receive(msg=('msg1', I1), from_ = I2):
        # The receiver first checks that the process id in the message matches
        # the source of the message given by the from_ field.
        if I1 == I2:

            # If so, then the receiver generates a nonce that will be encrypted
            # for the keyserver. The receiver will use this nonce to ensure
            # that the response from the keyserver containing the new session
            # key is fresh--that it is not an attempt to replay an old session
            # key response because an old response will not contain the new
            # nonce.
            N1_R = nonce()

            # Msg 2 of the corrected NS-SK does not appear in the uncorrected
            # version. It contains the process id of the initiator sent in the
            # first message and the new nonce encrypted with the key the
            # receiver shares with the keyserver.
            send(('msg2', encrypt((I1, N1_R), key = K_RS)), to = I1)

            # Msg 5 of the corrected NS-SK is almost the same as the third
            # message of the uncorrected protocol. It contains a tuple of
            # the process id of the initiator, the nonce sent to the keyserver
            # and the new session key encrypted with the key shared by the
            # receiver and the keyserver
            # The value of the process id and the nonce must be checked against
            # the saved valued before the protocol can proceed.
            await(some(received(('msg5', enc_SR), from_ = _I1),
                       has = ((N1_R == decrypt(enc_SR, key = K_RS)[1]) and
                              (I1 == decrypt(enc_SR, key = K_RS)[2]))))
            K_IR = decrypt(enc_SR, key = K_RS)[0]

            # The receiver now generates a new nonce it can use to assure
            # itself and the initiator that each is in possession of the new
            # session key.
            N2_R = nonce()

            # Msg 6 of the corrected NS-SK is identical to the fourth message
            # of the uncorrected protocol. It contains just the new nonce
            # encrypted with the new session key. It proves to the initiator
            # that the receiver possesses the new session key.
            send(('msg6', encrypt(N2_R, key = K_IR)), to = I1)

            # Msg 7 of the corrected NS-SK is identical to the fifth message of
            # the uncorrected protocol. It contains a modified nonce encrypted
            # with the new session key. It proves to the receiver that the
            # initiator possesses the new session key.
            await(some(received(('msg7', enc_IR), from_ = _I1),
                       has = ((N2_R - 1) == decrypt(enc_IR, key = K_IR))))
            output('R - Key Exchange Complete')

def main():
    K_IS = keygen('shared')
    K_RS = keygen('shared')
    S = new(RoleS, (K_IS, K_RS))
    R = new(RoleR, (S, K_RS))
    I = new(RoleI, (S, K_IS, R))
    start(S)
    start(R)
    start(I)
