#Transport Layer Security (TLS) Protocol Version 1.2
#single process class, no encapsulation
import time, sys
from sa.sec_algo_pycrypto import (encrypt, decrypt, sign,
                                  verify, genkey, gen_nonce)

#Protocol version number for SSL/TLS
PROTOCOL_VERSION_3_0 = (3, 0) #SSL 3.0
PROTOCOL_VERSION_1_0 = (3, 1) #TLS 1.0
PROTOCOL_VERSION_1_1 = (3, 2) #TLS 1.1
PROTOCOL_VERSION_1_2 = (3, 3) #TLS 1.2

#Enumerated values for the ContentType of Record Layer messages
TYPE_CHANGE_CIPHER_SPEC = 20
TYPE_ALERT              = 21
TYPE_HANDSHAKE          = 22
TYPE_APPLICATION_DATA   = 23

CHANGE_CIPHER_SPEC_BODY = 1

#Enumerated values for Handshake types; a byte is used for the message type in
#Handshake messages
HELLO_REQUEST       = 0
CLIENT_HELLO        = 1
SERVER_HELLO        = 2
CERTIFICATE         = 11
SERVER_KEY_EXCHANGE = 12
CERTIFICATE_REQUEST = 13
SERVER_HELLO_DONE   = 14
CERTIFICATE_VERIFY  = 15
CLIENT_KEY_EXCHANGE = 16
FINISHED            = 20

#Enumerated values for Client Certificate Types
RSA_SIGN                  = 1
DSS_SIGN                  = 2
RSA_FIXED_DH              = 3
DSS_FIXED_DH              = 4
RSA_EPHEMERAL_DH_RESERVED = 5
DSS_EPHEMERAL_DH_RESERVED = 6
FORTEZZA_DMS_RESERVED     = 20

#Enumerated values of connection end types (ConnectionEnd)
CONN_SERVER = 0
CONN_CLIENT = 1

#Enumerated values of psuedo-random functions (PRFAlgorithm)
TLS_PRF_SHA256 = 0

#Enumerated values of encryption algorithm types (CipherType)
CIPHER_STREAM = 0
CIPHER_BLOCK  = 1
CIPHER_AEAD   = 2

#Enumerated values of bulk encryption algorithms (BulkCipherAlgorithm)
BULK_NULL = 0
BULK_RC4  = 1
BULK_3DES = 2
BULK_AES  = 3

#Enumerated values of MAC algorithms
MAC_NULL        = 0
MAC_HMAC_MD5    = 1
MAC_HMAC_SHA1   = 2
MAC_HMAC_SHA256 = 3
MAC_HMAC_SHA384 = 4
MAC_HMAC_SHA512 = 5

#Enumerated values of compression algorithms
COMP_NULL = 0

#Enumerated values of cipher suites
TLS_RSA_WITH_AES_256_CBC_SHA256 = (0, 61)

class TLS_Peer(process):
    def setup(ce, peer):
        self.supported_tls_versions = (PROTOCOL_VERSION_1_2,)
        self.supported_cipher_suites = (TLS_RSA_WITH_AES_256_CBC_SHA256,)
        #SecurityParameters defined on p. 17 of RFC 5246
        self.current_rsp = Security_Parameters(ce)
        self.current_wsp = Security_Parameters(ce)
        self.pending_rsp = Security_Parameters(ce)
        self.pending_wsp = Security_Parameters(ce)
          
        self.current_read_state = Connection_State()
        self.current_write_state = Connection_State()
        self.pending_read_state = Connection_State()
        self.pending_write__state = Connection_State()

    def record_wrapper(content_type, tls_message):
        version = PROTOCOL_VERSION_1_2
        #will need to figure out how to implement proper fragmentation
        pt_fragment = tls_message

        #will need to determine length of fragment in bytes
        pt_length = None

        #First, build a TLSPlaintext message
        #TLSPlaintext = (type, version, length, fragment
        tls_pt = (content_type, version, pt_length, pt_fragment)

        #Second, apply the configured compression algorithm.
        #There is always an active compression algorith, but the default
        #compression algorithm is the Null algorithm, which applies no
        #compression
        #TLSCompressed = (type, version, length, fragment)
        comp_length = pt_length
        if current_sp['compression_algorithm'] != COMP_NULL:
            comp_fragment = current_sp['compression_algorithm'](pt_fragment)
        else:
            comp_fragment = pt_fragment
        tls_comp = (content_type, version, comp_length, comp_fragment)

        #Third, apply the agreed-upon encryption and MAC algorithms
        #The type of the agreed-upon bulk encryption algorithm determines the
        #form of the structure used to contain the ciphertext.
        #Like compression methods, there is a NULL encryption algorithm that is
        #used by default when a TLS connection is initialized. The NULL
        #encryption method is treated as a stream type bulk encryption
        #algorithm. It uses the GenericStreamCipher structure to enclose the
        #plaintext.
        #GenericStreamCipher = (content, MAC)
        cipher_length = comp_length
        if current_sp['cipher_type'] == CIPHER_STREAM:
            #The Message Authentication Code (MAC) must be computed
            #If the mac_algorithm field is NULL, then the mac_length field will
            #also be NULL and so there is no MAC.
            if current_sp['mac_algorithm'] == MAC_NULL:
                cipher_mac = b''
            else:
                cipher_mac = sign((sequence_number, content_type, version,
                                   comp_length, comp_fragment), key = mac_key)
            stream_ciphered = (comp_fragment, cipher_mac)

            #The cipher fragment must now be encrypted, unless the agreed-upon
            #encryption algorithm is none
            if current_sp['bulk_cipher_algorithm'] != BULK_NULL:
                cipher_fragment = encrypt(stream_ciphered, key = encryption_key)
            else:
                cipher_fragment = stream_ciphered

        #GenericBlockCipher = (iv, encrypt(content, mac, padding, padding_length))
        elif current_sp['cipher_type'] == CIPHER_BLOCK:
            #For block encryption we first generate an IV
            iv = genkey('random', current_sp['record_iv_length'])

            #Then we generate the MAC just as above
            if current_sp['mac_algorithm'] == MAC_NULL:
                cipher_mac = b''
            else:
                cipher_mac = sign((sequence_number, content_type, version,
                                   comp_length, comp_fragment), key = mac_key)

            #padding must then be computed
            #In order to do explicit padding here, padding done by the library
            #must be switched off
            #May want the amount of padding to be application configurable
            #because it can be used to prevent traffic analysis attacks
            #Can't do padding here until content is encoded as bytes
            #Will treat all messages as block length, 0 padding bytes
            cipher_padding = b''
            cipher_pad_length = 0
            block_ciphered = (comp_fragment, cipher_mac,
                               cipher_padding, cipher_pad_length)
            cipher_fragment = (iv, encrypt(block_ciphered, key = cipher_key))

        tls_cipher = (content_type, version, cipher_length, cipher_fragment)
        return tls_cipher
    
    def record_unwrapper(tls_cipher):
        #First, unpack tls_cipher
        content_type, version, cipher_length, cipher_fragment = tls_cipher

        #Second, check version
        if version != PROTOCOL_VERSION_1_2:
            #send error
            return

        #Third, use session state and security parameters to decrypt fragment
        #Begin by checking type of bulk encryption algorithm
        #then, decrypt and unpack cipher block
        if current_sp['cipher_type'] == CIPHER_STREAM:
            if current_sp['bulk_cipher_algorithm'] == BULK_NULL:
                (comp_fragment, cipher_mac) = cipher_fragment
            else:
                (comp_fragment, cipher_mac) = decrypt(cipher_fragment,
                                                      key = cipher_key)
        elif current_sp['cipher_type'] == CIPHER_BLOCK:
            (iv, block_ciphered) = cipher_fragment
            (comp_fragment, cipher_mac, cipher_padding,
             cipher_pad_length) = decrypt(block_ciphered, key = cipher_key)

        comp_length = cipher_length
        #Third, verify the MAC
        if current_sp['mac_algorithm'] != MAC_NULL:
            if not verify((sequence_number, content_type, version,
                           comp_length, comp_fragment),cipher_mac, key = mac_key):
                #send message authentication error
                return

        #Fourth, apply the active decompression method
        pt_length = comp_length
        if current_sp['compression_algorithm'] != COMP_NULL:
            pt_fragment = current_sp['compression_algorithm'](comp_fragment, 'decompress')
        else:
            pt_fragment = comp_fragment

        #Now strip Record layer fields and return enclosed TLS message
        #Stripping the Record layer fields is acceptable because they are
        #never encrypted and only the Record layer requires them to determine
        #which higher-level TLS protocol is being run on top of the Record
        #layer.
        return pt_fragment
                      
            
    def handshake_wrapper(handshake_type, body):
        #Will need to compute body length in bytes eventually
        #Handshake = (msg_type, length, body)
        return (handshake_type, None, body)
        
    def run():
        if False:        
        #if ce == CONN_CLIENT:
            #TLS Handshake with randomly chosen peer as server
            server = random.choice(tuple(peers))
            #First Handshake message is the client_hello
            #Client_Hello = (client_version, random, session_id, cipher_suites,
            #                compression_methods, extensions)
            body_client_hello= (PROTOCOL_VERSION_1_2,
                                (time.time(), genkey('random', 28)), None,
                                (TLS_RSA_WITH_AES_256_CBC_SHA256,), (0,), None)
            #This is wrapped in a Handshake type message
            #Handshake = (msg_type, length, body)
            #I will ignore length until Record layer fragmentation is working
            handshake_ch = (CLIENT_HELLO, None, body_client_hello)
            send(record_wrapper(TYPE_HANDSHAKE, handshake_ch), to = server)
            
            #Client end of TLS Handshake will now wait for a ServerHelloDone
            #ServerHelloDone = 
            await(some(received(msg, from_ = server),
                       has = (msg[0] == TYPE_HANDSHAKE and
                              (SERVER_DONE, None, ()) == record_unwrapper(msg))))
            
            #Seventh Handshake message is Certificate from the client
            #only if necessary - RFC 5246, pp. 47 and 54-56
            #Certificate = (certificate_list)
            #This is wrapped in a Handshake type message
            #Handshake = (msg_type, length, body)
            
            #Eighth Handshake message is Client_Key_Exchange
            #Client_Key_Exchange = (exchange_keys,)
            #Format of exchange_keys structure depends upon the agreed-upon
            #public key encryption algorithm
            #For RSA:
            #PreMasterSecret = (client_version, random[46])
            pre_master_secret = (PROTOCOL_VERSION_1_2, genkey('random', 46))
            #Which is contained in an EncryptedPreMasterSecret
            #EncryptedPreMasterSecret = (pre_master_secret,)
            exchange_keys = (encrypt(pre_master_secret,
                                     key = server_public_key),)
            body_cke = (encrypted_pre_master_secret,)
            #This is wrapped in a Handshake type message
            #Handshake = (msg_type, length, body)
            handshake_cke = (CLIENT_KEY_EXCHANGE, None, body_cke)
            send(record_wrapper(TYPE_HANDSHAKE, handshake_cke), to = server)
            
            #Ninth Handshake message is CertificateVerify from the client
            #only if necessary
            #CertificateVerify = (digitally_signed(handshake_messages),)
            #This is wrapped in a Handshake type message
            #Handshake = (msg_type, length, body)

            #Tenth Handshake message is ChangeCipherSpec
            #This is not really a Handshake protocol message.
            #ChangeCipherSpec is treated as a separate TLS protocol.
            #ChangeCipherSpec = (type,)
            #where type is always equal to 1
            handshake_ccs = (CHANGE_CIPHER_SPEC_BODY,)
            send(record_wrapper(TYPE_CHANGE_CIPHER_SPEC, handshake_ccs),
                 to = server)
            #Immediately after sending this message, the sender must replace
            #their current write session state with the pending write session
            #state

            #Eleventh Handshake message is Finished from the client
            #Finished = (verify_data,)
            #verify_data = PRF(master_secret, finished_label,
            #                  Hash(handshake_messages))
            #finished_label = "client finished", when sent by client
            verification_data = PRF(master_secret, 'client_finished', SHA256())
            finished = (verification_data,)
            handshake_fin = (FINISHED, None, finished)
            send(record_wrapper(TYPE_HANDSHAKE, handshake_fin), to = server)
            
            #The server will also have sent, or will send, a ChangeCipherSpec
            #message causing the client to replace its current read session
            #state with its pending read session state.
            #Will now await the Finished message from the server.
            await(some(received(msg, from_ = server),
                       has = (msg[0] == TYPE_HANDSHAKE and
                              (FINISHED, None, finish_data) == record_unwrapper(msg))))
            #Handshake complete
        await(False)

    #Receives Handshake type tls messages, but the messages are still enclosed
    #within the Record layer structure
    def receive(msg=(TYPE_HANDSHAKE, PROTOCOL_VERSION_1_2,
                     None, cipher_fragment), from_ = client):
        handshake_msg = record_unwrapper(TYPE_HANDSHAKE, PROTOCOL_VERSION_1_2,
                                         None, cipher_fragment)

        #Handshake messages must be recieved in the proper order. Handling of
        #other types of Handshake messages are handled further into the receive
        #handler. So only receipt of the ClientHello will continue from here.
        if (CLIENT_HELLO, _, _) != handshake_msg:
            return

        #Unpack the Client Hello
        #Client_Hello = (client_version, random, session_id, cipher_suites,
        #                compression_methods, extensions)
        (client_version, random, session_id,
         cipher_suites, compression_methods, extensions) = handshake_msg
        
        #In response to the ClientHello message, the server end will construct
        #a ServerHello Response.
        #First step is to determine the version of TLS that both client and
        #server can use. The server will select the lower of the version
        #requested by the client and the highest supported by the server.
        #Server will need to maintain list of supported versions of TLS,
        #currently this will just be 1.2
        server_version = min(client_version, max(supported_tls_versions))

        #Second, server generates a random value, just as the client had done.
        server_random = (time.time(), genkey('random', 28))

        #Third, server selects a session_id for this connection, unless the
        #client has included a non-empty session_id in an attempt to resume or
        #duplicate a prior session.
        #Session resumption can only be done if the server has cached the
        #security parameters associated with the given session_id.
        #The server can always choose to insist on a full handshake, even if it
        #retains the cached security parameters.
        #If the server wants to indicate that the session being established
        #will not be cached it can return an empty session_id.
        if session_id != None:
            output('Client attempting abbreivated handshake.')
            #check cache for associated security parameters.
            #if resumption okay, make stores parameters the pending parameters
            #then skip to (change_cipher_spec and) Finished messages
        else:
            #I will set session_id to none for now until renewable sessions
            #added.
            session_id = None
            
            #Fourth, pick a cipher suite usable by both server and client
            cipher_suite = setof(suite, suite in cipher_suites,
                                 suite in supported_cipher_suites).pop()

            #Fifth, pick a compression method usable by both server and client
            compression_method = setof(method, method in compression_methods,
                                       method in supported_compression_methods)

            #Now we can construct the ServerHello message
            #ServerHello = (server_version, random, session_id,
            #               cipher_suite, compression_method, extensions)
            body_sh = (server_version, server_random, session_id,
                       cipher_suite, compression_method, extensions)

            #Which is then wrapped in a Handshake message
            #Handshake = (msg_type, length, body)
            handshake_sh = (SERVER_HELLO, None, body_sh)
            send(record_wrapper(TYPE_HANDSHAKE, handshake_sh), to = client)
            
            #The server will next send a server Certificate message,
            #if required. This message is required whenever the agreed upon
            #key exchange method (determined by the chosen cipher suite, uses
            #certificates for authentication.
            #The server will need to possess valid certificate for every kind
            #of key exchange method it claims to support.
            server_certificate_body = (certificate_list,)
            handshake_sc = (CERTIFICATE, None, server_certificate_body)
            send(record_wrapper(TYPE_HANDSHAKE, handshake_sc), to = client)

            #The server will send as the third Handshake message a
            #ServerKeyExchange message, if it is required. Again this is
            #determined by the key exchange method determined by the agreed-
            #upon cipher suite
            #I am currently assuming RSA for the key exchange, which does not
            #require this message (In fact, it requires that this message not be
            #sent.
            #ServerKeyExchange = (params, signed_params)

            #The server will then send a CertificateRequest, if it requires the
            #client to authenticate itself with a Certificate.
            #Whether this message is sent and the type of certificates allowed
            #in response depend upon the cipher suite agreed upon for this
            #session.
            #CertificateRequest = (certificate_types,
            #                      suported_signature_algorithms,
            #                      certificate_authorities)
            #We will assume the server does not require the client to
            #authenticate itself for now.

            #Finally, the server will send a HelloDone message to indicate that
            #that it has sent all of its messages for establishing the security
            #parameters for the session.
            #The HelloDone message has an empty body.
            hello_done_body = ()
            handshake_hd = (SERVER_HELLO_DONE, None, hello_done_body)
            send(record_wrapper(TYPE_HANDSHAKE, handshake_hd), to = client)
            
            #The server will now await the ChangeCipherSpec message from the
            #client, 
            await(some(received((CHANGE_CIPHER_SPEC))))
            pass
        
def main():
    tls_server = new(TLS_Peer)
    #tls_client = new(TLS_Peer)
    setup(tls_server, (CONN_SERVER, None))
    #setup(tls_client, (CONN_CLIENT, tls_server))
    start(tls_server)
    #start(tls_client)

#This is the default method for generating new key material from shared secrets
#defined in RFC 5246 for use in the TLS protocol. It relies on HMAC-SHA256
#hashing function to generate pseudo-random bytes from given secret and seed
#values. The amount of key material that must be generated is determined by
#the agreed-upon cipher and mac algorithms contained in the security parameters
#Of the current TLS connection state.
def tls_prf_sha256(secret, label, seed, output_length):
    return _p_hash(secret, label + seed, output_length)


def _p_hash(secret, seed, output_length):
    from Crypto.Hash import HMAC
    from Crypto.Hash import SHA256
    result = bytearray()
    i = 1
    while len(result) < output_length:
        h = HMAC.new(secret, digestmod = SHA256)
        h.update(_a(i, secret, seed))
        h.update(seed)
        result.extend(h.digest())
        i += 1
    return bytes(result[:output_length])
    

def _a(n, secret, seed):
    from Crypto.Hash import HMAC
    from Crypto.Hash import SHA256
    if n == 0:
        return seed
    else:
        h = HMAC.new(secret, digestmod = SHA256)
        h.update(_a(n - 1, secret, seed))
        return h.digest()


class Security_Parameters():
    def __init__(self, ce):
        self.connection_end = ce
        self.prf_algorithm = TLS_PRF_SHA256
        self.bulk_cipher_algorithm = BULK_NULL
        self.cipher_type = CIPHER_STREAM
        self.enc_key_length = 0
        self.block_length = None
        self.fixed_iv_length = 0
        self.record_iv_length = 0
        self.mac_algorithm = MAC_NULL
        self.mac_length = 0
        self.mac_key_length = 0
        self.compression_method = COMP_NULL
        self.master_secret = None
        self.client_random = None
        self.server_random = None

class Connection_State():
    def __init__(self):
        self.compression_state = None
        self.cipher_state = None
        self.mac_key = None
        self.sequence_number = 0
