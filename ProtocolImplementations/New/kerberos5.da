"""
Kerberos Authentication Protocol v5


"""

from sa.sec_algo_pycrypto import genkey, gen_nonce, encrypt, decrypt

DEFAULT_TGT_DURATION = 36000 #ten hours
DEFAULT_AS_SKEW = 300 #five minutes

#authentication server
class Role_AS(process):
    def setup(client_keys, server_keys, key_TGS):
        self.supported_etypes = set()
        self.max_tgt_duration = DEFAULT_TGT_DURATION
        self.skew = DEFAULT_AS_SKEW
        self.per_client_lifetimes = dict()
        self.per_server_lifetimes = dict()

    def run():
        await(False)

    def receive(msg=('krb_as_req', pvno, msg-type, padata,
                     req-body), from_ = C):
        (kdc-options, cname, realm, sname, krb_from, till, rtime, nonce, etype,
         addresses, enc-authorization-data, additional-tickets) = req-body
        #check for repeated request
        #check for client and server
        if cname in client_keys:
            if sname in server_keys:
                #check etype list (session key must be usable by both the
                #client and the TGS
                #assumption AS and TGS support same etypes
                chosen_etype = None
                for et in etype:
                    if et in supported_etypes and chosen_etype == None:
                        chosen_etype = et
                if chosen_etype != None:
                    key_C_TGS = genkey('shared')
                    #check for preauthentication required
                    #check for preauthentication requested
                    #if postdate option is not set
                    #set starttime
                    if krb_from == None or (krb_from < (time.time() + skew)):
                        tgt_start = time.time()
                    #end if krb_from == None or startime < as time
                    #if postdate set, check that starttime is acceptable, copy
                    #to ticket, and set invalid flag
                    #set endtime (including special max value)
                    tgt_end = min(till,
                                  tgt_start + per_client_lifetimes[cname],
                                  tgt_start + per_server_lifetimes[sname],
                                  tgt_start + max_tgt_duration)
                    #if tgt_end < min_time, send error
                    #if till > tgt_end and Renewable-OK set, then set renewable
                    #flag in TGT and set renew-till field

                    #Build TGT
                    #First build encrypted part
                    #(flags, key, crealm, cname, transited, authtime,
                    # starttime, endtime, renew-till, caddr, authorization-data)
                    tgt_enc_part = (dict(), key_C_TGS, 'TEST', cname, [],
                                    tgt_start, tgt_start, tgt_end, 0, [], [])

                    #Next build ticket
                    #(tkt-vno, realm, sname, enc-part)
                    new_tgt = (5, 'TEST', sname,
                               encrypt(new_enc_part, key_AS_TGS))

                    #Build KRB-AS-REP
                    #First build encrypted part
                    #(key, last-req, nonce, key-expiration*, flags, authtime,
                    # starttime*, endtime, renew-till*, srealm, sname, caddr*)
                    as_rep_enc_part = (key_C_TGS, (0, 0), nonce, 0, dict,
                                       tgt_start, tgt_start, tgt_end, 0, 'TEST',
                                       sname, [])

                    #Now send reply
                    #(pvno, msg-type, padata*, crealm, cname, ticket, enc-part)
                    send(('krb_as_rep', 5, 11, [], 'TEST', cname, new_tgt,
                          encrypt(as_rep_enc_part, client_keys[cname])), to = C)
                #end if chosen_etype != None
            #end if sname in server_keys
        #end if cname in client_keys
    #end receive(krb_as_req)


class role_C(process):
    def setup(AS, TGS, servers, key_C_AS):
        pass

    def run():
        
