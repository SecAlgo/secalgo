"""
Kerberos Authentication Protocol v5


"""
import sys, time, random
from sa.sec_algo_pycrypto import genkey, gen_nonce, encrypt, decrypt

DEFAULT_TGT_DURATION = 36000 #ten hours
DEFAULT_AS_SKEW = 300 #five minutes
KRB_AP_REQ_TYPE = 14 #msg-type value for krb_ap_req messages
#authentication server
class Role_AS(process):
    def setup(client_keys, server_keys, key_TGS):
        self.supported_etypes = {17, 18}
        self.max_tgt_duration = DEFAULT_TGT_DURATION
        self.skew = DEFAULT_AS_SKEW
        self.per_client_lifetimes = dict()
        for c in client_keys:
            per_client_lifetimes[c] = DEFAULT_TGT_DURATION
        self.per_server_lifetimes = dict()
        for s in server_keys:
            per_server_lifetimes[s] = DEFAULT_TGT_DURATION

    def run():
        await(False)

    def receive(msg=('krb_as_req', pvno, msg_type, padata,
                     req_body), from_ = C):
        (kdc_options, cname, realm, sname, krb_from, till, rtime, nonce, etype,
         addresses, enc_authorization_data, additional_tickets) = req_body
        #check for repeated request
        #check for client and server
        if cname in client_keys:
            if sname in server_keys:
                #check etype list (session key must be usable by both the
                #client and the TGS
                #assumption AS and TGS support same etypes
                chosen_etype = None
                for et in etype:
                    if et in supported_etypes and chosen_etype == None:
                        chosen_etype = et
                if chosen_etype != None:
                    key_C_TGS = genkey('shared')
                    #check for preauthentication required
                    #check for preauthentication requested
                    #if postdate option is not set
                    #set starttime
                    if krb_from == None or (krb_from < (time.time() + skew)):
                        
                        tgt_start = time.time()
                    #end if krb_from == None or startime < as time
                    #if postdate set, check that starttime is acceptable, copy
                    #to ticket, and set invalid flag
                    #set endtime (including special max value)
                    tgt_end = min(till,
                                  tgt_start + per_client_lifetimes[cname],
                                  tgt_start + per_server_lifetimes[sname],
                                  tgt_start + max_tgt_duration)
                    #if tgt_end < min_time, send error
                    #if till > tgt_end and Renewable-OK set, then set renewable
                    #flag in TGT and set renew-till field

                    #Build TGT
                    #First build encrypted part
                    #(flags, key, crealm, cname, transited, authtime,
                    # starttime, endtime, renew-till, caddr, authorization-data)
                    tgt_enc_part = [dict(), key_C_TGS, 'TEST', cname, [],
                                    tgt_start, tgt_start, tgt_end, 0, [], []]

                    #Next build ticket
                    #(tkt-vno, realm, sname, enc-part)
                    new_tgt = [5, 'TEST', sname,
                               encrypt(tgt_enc_part, key_TGS)]

                    #Build KRB-AS-REP
                    #First build encrypted part
                    #(key, last-req, nonce, key-expiration*, flags, authtime,
                    # starttime*, endtime, renew-till*, srealm, sname, caddr*)
                    as_rep_enc_part = [key_C_TGS, (0, 0), nonce, 0, dict(),
                                       tgt_start, tgt_start, tgt_end, 0, 'TEST',
                                    sname, []]

                    #Now send reply
                    #(pvno, msg-type, padata*, crealm, cname, ticket, enc-part)
                    send(('krb_as_rep', 5, 11, [], 'TEST', cname, new_tgt,
                          encrypt(as_rep_enc_part, client_keys[cname])), to = C)
                #end if chosen_etype != None
            #end if sname in server_keys
        #end if cname in client_keys
    #end receive(krb_as_req)

class Role_TGS(process):
    def setup(key_AS_TGS):
        pass

    def run():
        await(False)

    def receive(msg=('krb_tgs_req', 5, 12, padata, req_body), from_ = C):
        #First task is to retrieve and decrypt the ticket contained in the
        #authentication header (krb_ap_req) inside the padata field.
        #Need to figure out which key to use to decrypt ticket.
        #We are assuming a normal TGS exchange, and so the TGS will use the key
        #it shares with the AS to decrypt the ticket.
        #We are assuming that the only entry in the padata sequence is the
        #authentication header.
        #KRB_AP_REQ = [pvno, msg-type, ticket, authenticator]
        _, msg_type, tgt, authenticator = padata[0]
        #Check msg-type (should be 14)

        #Unpack TGT, and then decrypt it.
        #TICKET = [tkt-vno, realm, sname, enc-part]
        #ENC-PART = [flags, key, crealm, cname, transited, authtime,
        #            starttime, endtime, renew-till, caddr, authorization-data]
        (_, realm, sname, tgt_enc_part) = tgt
        (flags, key_C_TGS, crealm, cname, transited, authtime, starttime,
         endtime, renew_till, caddr, authorization_data) = decrypt(tgt_enc_part, key_AS_TGS)

        #Now, use session key in TGT to decrypt authenticator
        #authenticator = [authenticator-vno, crealm, cname, cksum*, cusec,
        #                 ctime, subkey*, seq-number*, authorization-data*]
        (_, crealm, cname, cksum, cusec, ctime,
         subkey, seq-number, autheorization-data) = decrypt(authenticator, key_C_TGS)
        
        #Verify checksum
        
class Role_S(process):
    def setup():
        pass

    def run():
        await(False)
        
class Role_C(process):
    def setup(AS, TGS, servers, key_C_AS):
        self.C = self

    def run():
        #select an application server to access
        S = random.choice(tuple(servers))
        #generate nonce
        nonce_C_AS = gen_nonce()        
        #send KRB_AS_REQ msg to acquire TGT from AS
        #AS-REQ-BODY = [kdc-options, cname*, realm, sname*, from*, till, rtime*,
        #            nonce, etype, addresses*, enc-authorization-data*,
        #            additional-tickets*]
        #etype 18 = aes256
        #etype 17 = aes128
        as_req_body = [dict(), C, 'TEST', S, 0, time.time() + (5 * 3600), 0,
                       nonce_C_AS, [18, 17], [], [], []] 
        send(('krb_as_req', 5, 10, [], as_req_body), to = AS)

        #await KRB_AS_REP containing TGT and session key
        #check of the crealm and cname fields done through pattern match in the
        #await statement
        await(some(received(('krb_as_rep', 5, 11, padata, 'TEST', _C, tgt,
                             enc_part), from_= AS)))
        #decrypt the enc-part of the response
        (key_C_TGS, last_req, nonce01, key_expiration, flags, authtime,
         starttime, endtime, renew_till, srealm, sname,
         caddr) = decrypt(enc_part, key_C_AS)
        #check that the returned nonce matches the one sent
        if nonce01 == nonce_C_AS:
            #check returned sname and srealm match those requested
            if sname == S and srealm == 'TEST':
                #check host address field (caddr), if used
                #MAY check the last-req and key_expiration fields to recommend
                #client change password
                output('Client - Sucessfully acquired TGT from AS')
                output(decrypt(enc_part, key_C_AS))
        else:
            key_C_TGS = None
            tgt = None

        if tgt != None:
            #begin exchange with TGS for application server ticket
            #we are currently assuming that the application server is within
            #the same realm as the client and the Key Distribution Center
            #send KRB_TGS_REQ message to acquire ticket for application server
            #First, prepare authentication header, KRB_AP_REQ
            #KRB_AP_REQ = [pvno, msg-type, ticket, authenticator]
            #authenticator = [authenticator-vno, crealm, cname, cksum*, cusec,
            #                 ctime, subkey*, seq-number*, authorization-data*]
            authenticator = [5, 'TEST', C, None, 0, time.time(), None, None, []]
            krb_ap_req = [5, 14, dict(), tgt, encrypt(authenticator, key_C_TGS)]
            #Second, prepare TGS_REQ_BODY
            #TGS_REQ_BODY = [kdc-options, cname*, realm, sname*, from*, till,
            #                rtime, nonce, etype, addresses,
            #                enc-authorization-data, additional-tickets]
            tgs_req_body = [dict(), None, 'TEST', S, 0,
                            time.time() + (5 * 3600), 0, gen_nonce(), [18, 17],
                            [], [], []]
            #Third, send KRB_TGS_REQ
            #KRB_TGS_REQ = [pvno, msg-type, padata, req-body]
            send(('krb_tgs_req',5, 12, [krb_ap_req], tgs_req_body), to = TGS)
            #await KRB_TGS_REP containing ticket and session key for server
            await(some(received(('krb_tgs_rep'), from_ = TGS)))
        
def main():
    num_clients = int(sys.argv[1]) if len(sys.argv) > 1 else 2
    num_servers = int(sys.argv[2]) if len(sys.argv) > 2 else 2
    C = new(Role_C, num = num_clients)
    S = new(Role_S, num = num_servers)
    TGS = new(Role_TGS)
    AS = new(Role_AS)
    client_keys = dict()
    for client in C:
        key = genkey('shared')
        setup(client, (AS, TGS, S, key))
        client_keys[client] = key
    server_keys = dict()
    for server in S:
        server_keys[server] = genkey('shared')
    key_AS_TGS = genkey('shared')
    setup(AS, (client_keys, server_keys, key_AS_TGS))
    setup(TGS, (key_AS_TGS,))
    start(AS)
    start(TGS)
    start(C)
