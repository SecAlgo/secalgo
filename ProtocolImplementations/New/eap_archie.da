"""
EAP Archie Protocol for mutual authentication and session establishment through
key derivation.
https://tools.ietf.org/html/draft-jwalker-eap-archie-01.txt

1. A -> P : S, SessionID
2. P -> S : SessionID, P, enc(nonceP, KEK), Binding, MAC1
3. A -> P : SessionID, enc(nonceAS, KEK), Binding, MAC2
4. P -> S : SessionID, MAC3
"""

from sa.sec_algo_pycrypto import genkey, encrypt, decrypt, gen_nonce

#KCK (128 bits), KEK (128 bits), and KDK (256 bits) together comprise the
#Archie Key, a long lived 512 bit secret shared by the Authenticator and Peer.

#nonce encryption is supposed to use the AES Key Wrap algorithm, which is built
#on top of the AES primitives offered by crypto libraries like pycrypto, or
#charm (or SecAlgo, for that matter). Defined in source document.

#Need an appropriate value for the "binding" variable: it is supposed to be a
#addressing information, concatenation of the Peer's address and the address of
#its target.

#Protocol complete one key derivation material has been distributed and
#authenticated. But, may want to add actual key derivation step.

#EAP Authenticator
#The end of the EAP link initiating the EAP authentication methods.
class RoleA (process):
    def setup(KCK, KEK, KDK, P):
        self.A = self

    def run():
        session_id = gen_nonce(256)
        send(('start', A, session_id), to = P)
        
        #need to check the MAC, if possible in the await, otherwise just after
        #the await
        await(some(received(('response', session_id, P, nonce_P,
                              binding, MAC1), from_ = P)))
        AuthNonce  = gen_nonce(256)
        nonce_A = encrypt(AuthNonce, key = KEK)
        MAC2 = aes_cbc_mac_96(A, nonce_P, session_id, nonce_A, binding,
                              key = KCK)
        send(('confirm', session_id, nonce_A, binding, MAC2), to = P)

        #must check MAC
        await(some(received(('finish', session_id, MAC3), from_ = P)))
        output('A - Archie Protocol Complete')

#EAP Peer
#The end of the EAP link that responds to the authenticator.
class RoleP (process):
    def setup(KCK, KEK, KDK):
        self.P = self

    def run():
        await(False)

    def receive(msg=('start', A, session_id), from_ = A):
        PeerNonce = gen_nonce(256)
        nonce_P = encrypt(PeerNonce, key = KEK)
        binding = 'uh'
        MAC1 = aes_cbc_mac_96(A, session_id, P, nonce_P, binding, key = KCK)
        send(('response', session_id, P, nonce_P,
              binding, MAC1), to = A)

        #need to check the MAC
        await(some(received(('confirm', session_id, c_nonce_A, binding, MAC2),
                            from_ = A)))
        MAC3 = aes_cbc_mac_96(session_id, key = KCK)
        send(('finish', session_id, MAC3), to = A)
        output('P - Archie Protocol Complete')

def main():
    KCK = genkey('shared', 16)
    KEK = genkey('shared', 16)
    KDK = genkey('shared', 32)
    P = new(RoleP, (KCK, KEK, KDK))
    A = new(RoleA, (KCK, KEK, KDK, P))
    start(P)
    start(A)

def aes_cbc_mac_96(*values, key):
    import pickle
    from Crypto.Cipher import AES
    input = b''
    for value in values:
        input += pickle.dumps(value)
    IV = (0).to_bytes(16, byteorder = 'little')
    pad_length = 16 - len(input) % 16
    input = input + bytearray([0] * pad_length)
    n = len(input) // 16
    for i in range(n):
        crypter = AES.new(key, AES.MODE_CBC, IV)
        IV = crypter.encrypt(input[(i*16):((i+1)*16)])
    return IV[0:12]
