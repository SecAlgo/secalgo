# -*- generated by 1.0.12 -*-
import da
PatternExpr_208 = da.pat.TuplePattern([da.pat.ConstantPattern('msg3'), da.pat.FreePattern('i'), da.pat.TuplePattern([da.pat.FreePattern('A'), da.pat.FreePattern('B'), da.pat.FreePattern('nA'), da.pat.FreePattern('encBS')])])
PatternExpr_224 = da.pat.BoundPattern('_BoundPattern225_')
PatternExpr_383 = da.pat.TuplePattern([da.pat.ConstantPattern('msg2'), da.pat.BoundPattern('_BoundPattern386_'), da.pat.FreePattern('encBS')])
PatternExpr_391 = da.pat.BoundPattern('_BoundPattern392_')
PatternExpr_431 = da.pat.TuplePattern([da.pat.ConstantPattern('msg4'), da.pat.BoundPattern('_BoundPattern434_'), da.pat.FreePattern('encAS')])
PatternExpr_439 = da.pat.BoundPattern('_BoundPattern440_')
PatternExpr_513 = da.pat.TuplePattern([da.pat.ConstantPattern('msg6'), da.pat.BoundPattern('_BoundPattern516_'), da.pat.FreePattern('encBA')])
PatternExpr_521 = da.pat.BoundPattern('_BoundPattern522_')
PatternExpr_645 = da.pat.TuplePattern([da.pat.ConstantPattern('msg1'), da.pat.FreePattern('i'), da.pat.FreePattern('A')])
PatternExpr_654 = da.pat.FreePattern('A2')
PatternExpr_712 = da.pat.TuplePattern([da.pat.ConstantPattern('msg5'), da.pat.BoundPattern('_BoundPattern715_'), da.pat.FreePattern('encSB')])
PatternExpr_720 = da.pat.BoundPattern('_BoundPattern721_')
PatternExpr_830 = da.pat.TuplePattern([da.pat.ConstantPattern('msg7'), da.pat.BoundPattern('_BoundPattern833_'), da.pat.FreePattern('encAB')])
PatternExpr_838 = da.pat.BoundPattern('_BoundPattern839_')
_config_object = {}
import pickle, sys
from sa.secalgoB import dec_proto_run_timer
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random import random
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad

class RoleS(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleSReceivedEvent_0', PatternExpr_208, sources=[PatternExpr_224], destinations=None, timestamps=None, record_history=None, handlers=[self._RoleS_handler_207])])

    def setup(self, kAS, kBS, loops, test_size, **rest_984):
        super().setup(kAS=kAS, kBS=kBS, loops=loops, test_size=test_size, **rest_984)
        self._state.kAS = kAS
        self._state.kBS = kBS
        self._state.loops = loops
        self._state.test_size = test_size
        Random.atfork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_203', block=False)
        _st_label_203 = 0
        while (_st_label_203 == 0):
            _st_label_203 += 1
            if self._state.terminate:
                _st_label_203 += 1
            else:
                super()._label('_st_label_203', block=True)
                _st_label_203 -= 1

    def _RoleS_handler_207(self, i, A, B, nA, encBS):
        cipher = AES.new(self._state.kBS, AES.MODE_CBC, encBS[:AES.block_size])
        nB1 = None

        def ExistentialOpExpr_241():
            nonlocal nB1
            for (_BoundPattern244_, nB1) in [pickle.loads(unpad(cipher.decrypt(encBS[AES.block_size:])))]:
                if (_BoundPattern244_ == A):
                    if True:
                        return True
            return False
        if ExistentialOpExpr_241():
            kAB = Random.new().read(self._state.test_size)
            ivB = Random.new().read(AES.block_size)
            cipherB = AES.new(self._state.kBS, AES.MODE_CBC, ivB)
            ivA = Random.new().read(AES.block_size)
            cipherA = AES.new(self._state.kAS, AES.MODE_CBC, ivA)
            self.send(('msg4', i, (ivA + cipherA.encrypt(pad(pickle.dumps((nA, kAB, B, (ivB + cipherB.encrypt(pad(pickle.dumps((kAB, nB1, A))))))))))), to=A)
        self._state.terminate = True
    _RoleS_handler_207._labels = None
    _RoleS_handler_207._notlabels = None

class RoleA(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleAReceivedEvent_0 = []
        self._RoleAReceivedEvent_1 = []
        self._RoleAReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_0', PatternExpr_383, sources=[PatternExpr_391], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_1', PatternExpr_431, sources=[PatternExpr_439], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_2', PatternExpr_513, sources=[PatternExpr_521], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, S, kAS, B, loops, **rest_984):
        super().setup(S=S, kAS=kAS, B=B, loops=loops, **rest_984)
        self._state.S = S
        self._state.kAS = kAS
        self._state.B = B
        self._state.loops = loops
        Random.atfork()
        self._state.i = 1

    @dec_proto_run_timer
    def run(self):
        self.send(('msg1', self._state.i, self._id), to=self._state.B)
        super()._label('_st_label_380', block=False)
        encBS = None

        def ExistentialOpExpr_381():
            nonlocal encBS
            for (_, (_, _, _BoundPattern399_), (_ConstantPattern401_, _BoundPattern403_, encBS)) in self._RoleAReceivedEvent_0:
                if (_BoundPattern399_ == self._state.B):
                    if (_ConstantPattern401_ == 'msg2'):
                        if (_BoundPattern403_ == self._state.i):
                            if True:
                                return True
            return False
        _st_label_380 = 0
        while (_st_label_380 == 0):
            _st_label_380 += 1
            if ExistentialOpExpr_381():
                _st_label_380 += 1
            else:
                super()._label('_st_label_380', block=True)
                _st_label_380 -= 1
        nA = random.StrongRandom().getrandbits(128)
        self.send(('msg3', self._state.i, (self._id, self._state.B, nA, encBS)), to=self._state.S)
        super()._label('_st_label_428', block=False)
        encAS = None

        def ExistentialOpExpr_429():
            nonlocal encAS
            for (_, (_, _, _BoundPattern447_), (_ConstantPattern449_, _BoundPattern451_, encAS)) in self._RoleAReceivedEvent_1:
                if (_BoundPattern447_ == self._state.S):
                    if (_ConstantPattern449_ == 'msg4'):
                        if (_BoundPattern451_ == self._state.i):
                            if True:
                                return True
            return False
        _st_label_428 = 0
        while (_st_label_428 == 0):
            _st_label_428 += 1
            if ExistentialOpExpr_429():
                _st_label_428 += 1
            else:
                super()._label('_st_label_428', block=True)
                _st_label_428 -= 1
        cipherAS = AES.new(self._state.kAS, AES.MODE_CBC, encAS[:AES.block_size])
        kAB = encSB = None

        def ExistentialOpExpr_471():
            nonlocal kAB, encSB
            for (_BoundPattern474_, kAB, _BoundPattern477_, encSB) in [pickle.loads(unpad(cipherAS.decrypt(encAS[AES.block_size:])))]:
                if (_BoundPattern474_ == nA):
                    if (_BoundPattern477_ == self._state.B):
                        if True:
                            return True
            return False
        if ExistentialOpExpr_471():
            kABu = kAB[:32]
            self.send(('msg5', self._state.i, encSB), to=self._state.B)
            super()._label('_st_label_510', block=False)
            encBA = None

            def ExistentialOpExpr_511():
                nonlocal encBA
                for (_, (_, _, _BoundPattern529_), (_ConstantPattern531_, _BoundPattern533_, encBA)) in self._RoleAReceivedEvent_2:
                    if (_BoundPattern529_ == self._state.B):
                        if (_ConstantPattern531_ == 'msg6'):
                            if (_BoundPattern533_ == self._state.i):
                                if True:
                                    return True
                return False
            _st_label_510 = 0
            while (_st_label_510 == 0):
                _st_label_510 += 1
                if ExistentialOpExpr_511():
                    _st_label_510 += 1
                else:
                    super()._label('_st_label_510', block=True)
                    _st_label_510 -= 1
            cipherBA = AES.new(kABu, AES.MODE_CBC, encBA[:AES.block_size])
            nB = pickle.loads(unpad(cipherBA.decrypt(encBA[AES.block_size:])))
            ivAB = Random.new().read(AES.block_size)
            cipherAB = AES.new(kABu, AES.MODE_CBC, ivAB)
            self.send(('msg7', self._state.i, (ivAB + cipherAB.encrypt(pad(pickle.dumps((nB - 1)))))), to=self._state.B)
            self.output('A - Key Exchange Complete')
        self._state.i += 1

class RoleB(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleBReceivedEvent_1 = []
        self._RoleBReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_0', PatternExpr_645, sources=[PatternExpr_654], destinations=None, timestamps=None, record_history=None, handlers=[self._RoleB_handler_644]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_1', PatternExpr_712, sources=[PatternExpr_720], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_2', PatternExpr_830, sources=[PatternExpr_838], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, S, kBS, loops, **rest_984):
        super().setup(S=S, kBS=kBS, loops=loops, **rest_984)
        self._state.S = S
        self._state.kBS = kBS
        self._state.loops = loops
        Random.atfork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_640', block=False)
        _st_label_640 = 0
        while (_st_label_640 == 0):
            _st_label_640 += 1
            if self._state.terminate:
                _st_label_640 += 1
            else:
                super()._label('_st_label_640', block=True)
                _st_label_640 -= 1

    def _RoleB_handler_644(self, i, A, A2):
        if (A == A2):
            nB1 = random.StrongRandom().getrandbits(128)
            ivBS = Random.new().read(AES.block_size)
            cipherBS = AES.new(self._state.kBS, AES.MODE_CBC, ivBS)
            self.send(('msg2', i, (ivBS + cipherBS.encrypt(pad(pickle.dumps((A, nB1)))))), to=A)
            super()._label('_st_label_709', block=False)
            encSB = None

            def ExistentialOpExpr_710():
                nonlocal encSB
                for (_, (_, _, _BoundPattern728_), (_ConstantPattern730_, _BoundPattern732_, encSB)) in self._RoleBReceivedEvent_1:
                    if (_BoundPattern728_ == A):
                        if (_ConstantPattern730_ == 'msg5'):
                            if (_BoundPattern732_ == i):
                                if True:
                                    return True
                return False
            _st_label_709 = 0
            while (_st_label_709 == 0):
                _st_label_709 += 1
                if ExistentialOpExpr_710():
                    _st_label_709 += 1
                else:
                    super()._label('_st_label_709', block=True)
                    _st_label_709 -= 1
            cipherBS = AES.new(self._state.kBS, AES.MODE_CBC, encSB[:AES.block_size])
            kAB = None

            def ExistentialOpExpr_751():
                nonlocal kAB
                for (kAB, _BoundPattern756_, _BoundPattern757_) in [pickle.loads(unpad(cipherBS.decrypt(encSB[AES.block_size:])))]:
                    if (_BoundPattern756_ == nB1):
                        if (_BoundPattern757_ == A):
                            if True:
                                return True
                return False
            if ExistentialOpExpr_751():
                kABu = kAB[:32]
                nB2 = random.StrongRandom().getrandbits(128)
                ivBA = Random.new().read(AES.block_size)
                cipherBA = AES.new(kABu, AES.MODE_CBC, ivBA)
                self.send(('msg6', i, (ivBA + cipherBA.encrypt(pad(pickle.dumps(nB2))))), to=A)
                super()._label('_st_label_827', block=False)
                encAB = None

                def ExistentialOpExpr_828():
                    nonlocal encAB
                    for (_, (_, _, _BoundPattern846_), (_ConstantPattern848_, _BoundPattern850_, encAB)) in self._RoleBReceivedEvent_2:
                        if (_BoundPattern846_ == A):
                            if (_ConstantPattern848_ == 'msg7'):
                                if (_BoundPattern850_ == i):
                                    if True:
                                        return True
                    return False
                _st_label_827 = 0
                while (_st_label_827 == 0):
                    _st_label_827 += 1
                    if ExistentialOpExpr_828():
                        _st_label_827 += 1
                    else:
                        super()._label('_st_label_827', block=True)
                        _st_label_827 -= 1
                cipherAB = AES.new(kABu, AES.MODE_CBC, encAB[:AES.block_size])
                if ((nB2 - 1) == pickle.loads(unpad(cipherAB.decrypt(encAB[AES.block_size:])))):
                    self.output('B - Key Exchange Complete')
        self._state.terminate = True
    _RoleB_handler_644._labels = None
    _RoleB_handler_644._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        loops = (int(sys.argv[1]) if (len(sys.argv) > 1) else 1000)
        test_size = (int(sys.argv[2]) if (len(sys.argv) > 2) else 32)
        kAS = Random.new().read(32)
        kBS = Random.new().read(32)
        S = self.new(RoleS, (kAS, kBS, loops, test_size))
        B = self.new(RoleB, (S, kBS, loops))
        A = self.new(RoleA, (S, kAS, B, loops))
        self._start(S)
        self._start(B)
        self._start(A)
