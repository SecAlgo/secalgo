"""
Kerberos Authentication Protocol v5 in DistAlgo
Written by Christopher Kane

Source:
C. Neuman, T. Yu, S. Hartman, K. Raeburn. "RFC 4120: The Kerberos Network
Authentication Service (v5)". July, 2005.

Protocol Diagram:
  (1) C   -> AuthServer  : KRB_AS_REQ
  (2) AuthServer  -> C   : KRB_AS_REP
  (3) C   -> TktGrantServer : KRB_TGS_REQ
  (4) TktGrantServer -> C   : KRB_TGS_REP
  (5) C   -> AppServer   : KRB_AP_REQ
  (6) AppServer   -> C   : KRB_AP_REP (only if mutual authentication used)

This diagram assumes the most straightforward instance of the authentication
protocol. It ignores the possibity of renewable tickets, postdated tickets,
forwardable or proxy tickets. It also ignores requests for pre-authentication,
or user-to-user authentication. 

C   = Client
AS  = Authentication Server
TGS = Ticket-Granting Server
S  = Application Server

"""

import sys, time, random, pickle
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random import random
from Crypto.Hash import HMAC
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad

DEFAULT_TGT_DURATION = 36000 # ten hours
DEFAULT_TKT_DURATION = 3600 # one hour
DEFAULT_SKEW = 300 # five minutes
KRB_AP_REQ_TYPE = 14 # msg-type value for krb_ap_req messages
ETYPE_AES_128_HMAC_SHA1_96 = 17 # cite
ETYPE_AES_256_HMAC_SHA1_96 = 18 # cite
CIPHER_AES = 0
MAC_HMAC = 0
CIPHERS = {CIPHER_AES : AES}
MACS = {MAC_HMAC : HMAC}

# Returns tuple of encryption alg, key, mac alg
def set_security_params(etype):
    cipher = {ETYPE_AES_128_HMAC_SHA1_96 : CIPHER_AES, ETYPE_AES_256_HMAC_SHA1_96 : CIPHER_AES}
    mac = {ETYPE_AES_128_HMAC_SHA1_96 : MAC_HMAC, ETYPE_AES_256_HMAC_SHA1_96: MAC_HMAC}
    keySizes = {ETYPE_AES_128_HMAC_SHA1_96 : 16, ETYPE_AES_256_HMAC_SHA1_96 : 32}
    return (cipher[etype], keySizes[etype], mac[etype])

#authentication server
class RoleAuthServer(process):
    #give citations to specification
    def setup(clients, servers, TGS, client_keys, server_keys, keyTGS):
        Random.atfork()
        self.supported_etypes = {ETYPE_AES_128_HMAC_SHA1_96,
                                 ETYPE_AES_128_HMAC_SHA1_96}
        self.max_tgt_duration = DEFAULT_TGT_DURATION
        self.skew = DEFAULT_SKEW
        self.per_client_lifetimes = dict()
        for c in clients:
            per_client_lifetimes[c] = DEFAULT_TGT_DURATION
        self.per_server_lifetimes = dict()
        for s in servers:
            per_server_lifetimes[s] = DEFAULT_TGT_DURATION

    def run():
        await(False)
        
    def receive(msg=('krb_as_req', pvno, msg_type, padata,
                     req_body), from_ = C):
        # unpack req_body
        (kdc_options, cname, realm, sname, krb_from, till, rtime, nonce, etype,
         addresses, enc_authorization_data, additional_tickets) = req_body

        # check for repeated request

        # check for client and server
        if cname not in clients:
            # send KRB_ERR_C_PRINCIPAL_UNKOWN msg
            return

        if sname not in servers:
            # Specification does not describe an error msg
            return

        # check for pre-authentication
        
        # check etype list (session key must be usable by both the
        # client and the TGS
        # assumption AS and TGS support same etypes
        # comprehension for choosing etype
        chosen_etype = None
        for et in etype:
            if et in supported_etypes and chosen_etype == None:
                chosen_etype = et
        if chosen_etype == None:
            # Send KDC_ERR_ETYPE_NOSUPP
            return

        # Set security parameters to match chosen etype
        params = set_security_params(chosen_etype)

        # Generate a key matching for the chosen encryption algorithm
        keyC_TGS = Random.new().read(params[1])

        # check for postdate or may_postdate option

        # set starttime
        if krb_from == None or (krb_from < (time.time() + skew)):
            tgt_start = time.time()
        else:
            # if postdate set, check that starttime is acceptable, copy
            # to ticket, and set invalid flag
            # else send KDC_ERR_CANNOT_POSTDATE
            return
        
        # set endtime (including special max value)
        tgt_end = min(till,
                      tgt_start + per_client_lifetimes[cname],
                      tgt_start + per_server_lifetimes[sname],
                      tgt_start + max_tgt_duration)
        # if tgt_end < min_time, send error
        # if till > tgt_end and Renewable-OK set, then set renewable
        # flag in TGT and set renew-till field
        
        # Build TGT
        # First build encrypted part
        # (flags, key, crealm, cname, transited, authtime,
        #  starttime, endtime, renew-till, caddr, authorization-data)
        tgt_enc_part = (dict(), (params, keyC_TGS), 'TEST', cname, [], tgt_start,
                        tgt_start, tgt_end, None, [], [])

        # Next build ticket
        # (tkt-vno, realm, sname, enc-part)
        tgtIV = Random.new().read(AES.block_size)
        tgtCipher = AES.new(keyTGS, AES.MODE_CBC, tgtIV)
        tgt = [5, 'TEST', sname, tgtIV + tgtCipher.encrypt(pad(pickle.dumps(tgt_enc_part)))]
        
        # Build KRB-AS-REP
        # First build encrypted part
        # (key, last-req, nonce, key-expiration*, flags, authtime,
        #  starttime*, endtime, renew-till*, srealm, sname, caddr*)
        as_rep_enc_part = [(params, keyC_TGS), (0, 0), nonce, 0, dict(), tgt_start,
                           tgt_start, tgt_end, 0, 'TEST', sname, []]
        
        # Now send reply
        # (pvno, msg-type, padata*, crealm, cname, ticket, enc-part)
        asRepIV = Random.new().read(AES.block_size)
        asRepCipher = AES.new(client_keys[cname], AES.MODE_CBC, asRepIV)
        send(('krb_as_rep', 5, 11, [], 'TEST', cname, tgt,
              asRepIV + asRepCipher.encrypt(pad(pickle.dumps(as_rep_enc_part)))), to = C)
        output('AS - Sent TGT to client,', cname)
        
class RoleTGS(process):
    def setup(servers, AS, keyAS_TGS, server_keys):
        Random.atfork()
        self.supported_etypes = {ETYPE_AES_128_HMAC_SHA1_96,
                                 ETYPE_AES_128_HMAC_SHA1_96}
        self.skew = DEFAULT_SKEW
        self.max_tkt_duration = DEFAULT_TKT_DURATION
        self.per_server_lifetimes = dict()
        for s in server_keys:
            per_server_lifetimes[s] = DEFAULT_TKT_DURATION

    def run():
        await(False)

    def receive(msg=('krb_tgs_req', 5, 12, padata, req_body), from_ = C):
        # First task is to retrieve and decrypt the ticket contained in the
        # authentication header (krb_ap_req) inside the padata field.
        # Need to figure out which key to use to decrypt ticket.
        # We are assuming a normal TGS exchange, and so the TGS will use the key
        # it shares with the AS to decrypt the ticket.
        # We are assuming that the only entry in the padata sequence is the
        # authentication header, KRB_AP_REQ.

        # KRB_AP_REQ = [pvno, msg-type, ap-options, ticket, authenticator]
        _, msg_type, ap_options, tgt, authenticator = padata[0]

        # Check msg-type (should be 14) krb_ap_req
        if msg_type != 14:
            # send KRB_ERROR msg
            return # replace with function to report error

        # Unpack TGT, and then decrypt it.
        # TICKET = [tkt-vno, realm, sname, enc-part]
        # ENC-PART = [flags, key, crealm, cname, transited, authtime,
        #             starttime, endtime, renew-till, caddr, authorization-data]
        (_, realm, sname, tgt_enc_part) = tgt
        tgtCipher = AES.new(keyAS_TGS, AES.MODE_CBC, tgt_enc_part[:AES.block_size]) 
        (tgt_flags, (paramsC_TGS, keyC_TGS), tgt_crealm, tgt_cname, tgt_transited,
         tgt_authtime, tgt_starttime, tgt_endtime, tgt_renew_till,
         tgt_caddr, tgt_authorization_data) = pickle.loads(unpad(tgtCipher.decrypt(tgt_enc_part[AES.block_size:])))

        # Now, use session key in TGT to decrypt authenticator
        # authenticator = [authenticator-vno, crealm, cname, cksum*, cusec,
        #                  ctime, subkey*, seq-number*, authorization-data*]
        cipherC_TGS = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC,
                                                  authenticator[:CIPHERS[paramsC_TGS[0]].block_size])
        (_, au_crealm, au_cname, cksum, cusec, ctime, subkey,
         seq_number, authorization_data) = pickle.loads(unpad(cipherC_TGS.decrypt(authenticator[CIPHERS[paramsC_TGS[0]].block_size:])))
        
        if tgt_cname != au_cname or tgt_crealm != au_crealm:
            # generate KRB_AP_ERR_BADMATCH msg
            return

        # check host addresses in caddr, if any

        # check that authenticator is fresh
        local_time = time.time()
        if abs(local_time - ctime) > skew:
            # send KRB_AP_ERR_SKEW msg
            return
        
        # check for replayed requests
        # need to build a replay cache based on received requests
        # it may be possible to use send to self decryption to use the received
        # set as the replay cache
        # check for sequence number (optional)
        # check for sub-session key (optional)

        # check validity of ticket timestamp
        if tgt_starttime > local_time + skew:
            # send KRB_AP_ERR_TKT_NYV
            return

        if local_time - tgt_endtime > skew:
            # send KRB_AP_ERR_TKT_EXPIRED msg
            return

        # TGS has now authenticated identity of client
        output('TGS - Authenticated client:', au_cname)

        # Now that the client's identity has been authenticated, its request for
        # credentials for an application server can now be processed.
        # unpack req_body
        (kdc_options, cname, realm, sname, krb_from, till, rtime, nonce, etype,
         addresses, enc_authorization_data, additional_tickets) = req_body
        
        # check for repeated request
        # check for server
        if sname not in server_keys:
            # send KRB_ERR msg
            return
        
        # check etype list (session key must be usable by both the
        # client and the application server
        # assumption TGS and application servers support same etypes
        chosen_etype = None
        for et in etype:
            if et in supported_etypes and chosen_etype == None:
                chosen_etype = et
        if chosen_etype == None:
            # send KRB_ERR msg
            return

        # Set security parameters to match chosen etype
        paramsC_S = set_security_params(chosen_etype)
        
        # generate shared session key for client and application server
        keyC_S = Random.new().read(paramsC_S[1])

        # check for preauthentication required
        # check for preauthentication requested
        # check postdate option is not set
        # set starttime
        if krb_from == None or (krb_from < (local_time + skew)):
            ticket_start = local_time
            
        # end if krb_from == None or startime < as time
        # if postdate set, check that starttime is acceptable, copy
        # to ticket, and set invalid flag
        # set endtime (including special max value)
        ticket_end = min(till,
                         tgt_endtime,
                         tgt_starttime + per_server_lifetimes[sname],
                         tgt_starttime + max_tkt_duration)
        # if tgt_end < min_time, send error
        # if till > tgt_end and Renewable-OK set, then set renewable
        # flag in Ticket and set renew-till field

        # Build Ticket
        # First build encrypted part
        # (flags, key, crealm, cname, transited, authtime,
        #  starttime, endtime, renew-till, caddr, authorization-data)
        ticket_enc_part = [dict(), (paramsC_S, keyC_S), tgt_crealm, tgt_cname,
                           tgt_transited, tgt_authtime, ticket_start,
                           ticket_end, 0, tgt_caddr, []]

        # Next build ticket
        # (tkt-vno, realm, sname, enc-part)
        tktIV = Random.new().read(AES.block_size)
        tktCipher = AES.new(server_keys[sname], AES.MODE_CBC, tktIV)
        new_ticket = [5, 'TEST', sname,
                      tktIV + tktCipher.encrypt(pad(pickle.dumps(ticket_enc_part)))]
            
        # Build KRB-TGS-REP
        # First build encrypted part
        # (key, last-req, nonce, key-expiration*, flags, authtime,
        #  starttime*, endtime, renew-till*, srealm, sname, caddr*)
        tgs_rep_enc_part = [(paramsC_S, keyC_S), (0, 0), nonce, 0, dict(),
                               tgt_authtime, ticket_start, ticket_end, 0,
                               'TEST', sname, tgt_caddr]
            
        # Now send reply
        # (pvno, msg-type, padata*, crealm, cname, ticket, enc-part)
        output('TGS - Sent Ticket for server', sname, 'to client,', C)
        tgsRepIV = Random.new().read(CIPHERS[paramsC_TGS[0]].block_size)
        tgsRepCipher = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC, tgsRepIV)
        send(('krb_tgs_rep', 5, 13, [], 'TEST', tgt_cname, new_ticket,
              tgsRepIV + tgsRepCipher.encrypt(pad(pickle.dumps(tgs_rep_enc_part)))), to = C)        
        
class RoleAppServer(process):
    def setup(AS, TGS, keyS_AS, keyS_TGS):
        Random.atfork()
        self.S = self
        self.skew = DEFAULT_SKEW

    def run():
        await(False)

    # KRB_AP_REQ = [pvno, msg-type, ap-options, ticket, authenticator]
    def receive(msg=('krb_ap_req', 5, 14, ap-options, ticket, authenticator),
                from_ = C):
        # message type check accomplished through pattern matach (but this may
        # not be correct, since a wrong msg-type should generate an error msg.
        # First, check msg-type = 14 (KRB_AP_REQ)
        # Second, check key version in the ticket to make sure server still uses
        # that key.
        # Third, check USE-SESSION-KEY flag in ap-options.
        # Fourth, use srealm field in ticket to determine which key to use.

        # Fifth, use the secret key shared by TGS and Server to decrypt ticket
        # Unpack ticket = [tkt-vno, realm, sname, enc-part]
        tkt_vno, realm , sname, tkt_enc_part = ticket

        # Decrypt and unpack enc-part
        # enc-part = [flags, key, crealm, cname, transited, authtime,
        #             starttime*, endtime, renew-till*, caddr*,
        #             authorization-data*]
        tktCipher = AES.new(keyS_TGS, AES.MODE_CBC, tkt_enc_part[:AES.block_size])
        (tkt_flags, (paramsC_S, keyC_S), tkt_crealm, tkt_cname, tkt_transited,
         tkt_authtime, tkt_starttime, tkt_endtime, tkt_renew_till, tkt_caddr,
         tkt_authorization_data) = pickle.loads(unpad(tktCipher.decrypt(tkt_enc_part[AES.block_size:])))

        # Sixth, use the session key from the decrypted ticket to decrypt the
        # authenticator
        # Decrypt and unpack authenticator
        # authenticator = [authenticator-vno, crealm, cname, cksum*, cusec,
        #                  ctime, subkey*, seq-number*, authorization-data*]
        cipherC_S = CIPHERS[paramsC_S[0]].new(keyC_S, CIPHERS[paramsC_S[0]].MODE_CBC, authenticator[:CIPHERS[paramsC_S[0]].block_size])
        (_, au_crealm, au_cname, au_cksum, au_cusec,
         au_ctime, au_subkey, au_seq_number,
         au_authorization_data) = pickle.loads(unpad(cipherC_S.decrypt(authenticator[CIPHERS[paramsC_S[0]].block_size:])))

        # check that client name and realm from ticket match those in the
        # authenticator
        if au_crealm != tkt_crealm or au_cname != tkt_cname:
            # send KRB_AP_ERR_BADMATCH
            return

        # check addresses listed in tkt_caddr (if any)

        # check that authenticator is fresh
        local_time = time.time()
        if abs(local_time - au_ctime) > skew:
            #send KRB_AP_ERR_SKEW
            return

        # check for replay of authenticators
        # save sequence number for later use (if present)
        # save sub-session key for later use (if present)

        # check that the ticket has a valid timestamp, which means its starttime
        # is earlier, and its endtime is later, than the current time (with
        # allowance for the configured skew time)
        if tkt_starttime > local_time + skew:
            # send KRB_AP_ERR_TKT_NYV
            return
        
        if local_time - tkt_endtime > skew:
            # send KRB_AP_ERR_TKT_EXPIRED msg
            return

        # S has now authenticated identity of client
        output('Server:', S, '- Authenticated client:', au_cname)
        
class RoleC(process):
    def setup(realm, servers, AS, TGS, keyC_AS):
        Random.atfork()
        self.C = self

    def run():
        # select an application server to access
        S = random.choice(tuple(servers))
        # generate nonce
        nonce_C_AS = random.StrongRandom().getrandbits(128)        
        # send KRB_AS_REQ msg to acquire TGT from AS
        # AS-REQ-BODY = [kdc-options, cname*, realm, sname*, from*, till, rtime*,
        #             nonce, etype, addresses*, enc-authorization-data*,
        #             additional-tickets*]
        # etype 18 = AES_128_HMAC_SHA1_96
        # etype 17 = AES_256_HMAC_SHA1_96
        as_req_body = [dict(), C, 'TEST', S, 0, time.time() + (5 * 3600), 0,
                       nonce_C_AS, [ETYPE_AES_128_HMAC_SHA1_96, ETYPE_AES_256_HMAC_SHA1_96], [], [], []]
        output('Client - Sent request to AS for credentials for server,', S)
        send(('krb_as_req', 5, 10, [], as_req_body), to = AS)

        # await KRB_AS_REP containing TGT and session key
        # check of the crealm and cname fields done through pattern match in the
        # await statement
        # This await condition is not correct; need to figure out the correct
        # behavior, and then compose the right await condition
        await(some(received(('krb_as_rep', 5, 11, padata, 'TEST', _C, tgt,
                             enc_part), from_= _AS)))

        # decrypt the enc-part of the response
        asRepCipher = AES.new(keyC_AS, AES.MODE_CBC, enc_part[:AES.block_size])
        ((paramsC_TGS, keyC_TGS), last_req, as_nonce, key_expiration, flags, authtime,
         starttime, endtime, renew_till, srealm, sname,
         caddr) = pickle.loads(unpad(asRepCipher.decrypt(enc_part[AES.block_size:])))

        # check that the returned nonce matches the one sent
        if as_nonce == nonce_C_AS:
            # check returned sname and srealm match those requested
            if sname == S and srealm == 'TEST':
                # check host address field (caddr), if used
                # MAY check the last-req and key_expiration fields to recommend
                # client change password
                output('Client - Acquired TGT from AS')
                # output(decrypt(enc_part, key_C_AS))
        else:
            keyC_TGS = None
            tgt = None

        if tgt != None:
            # begin exchange with TGS for application server ticket
            # we are currently assuming that the application server is within
            # the same realm as the client and the Key Distribution Center
            # send KRB_TGS_REQ message to acquire ticket for application server

            # First, prepare authentication header, KRB_AP_REQ
            # KRB_AP_REQ = [pvno, msg-type, ap-options, ticket, authenticator]
            # authenticator = [authenticator-vno, crealm, cname, cksum*, cusec,
            #                  ctime, subkey*, seq-number*, authorization-data*]
            tgsReqIV = Random.new().read(CIPHERS[paramsC_TGS[0]].block_size)
            tgsReqCipher = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC, tgsReqIV)
            authenticator = [5, realm, C, None, 0, time.time(), None, None, []]
            tgs_krb_ap_req = [5, 14, dict(), tgt,
                              tgsReqIV + tgsReqCipher.encrypt(pad(pickle.dumps(authenticator)))]

            # Second, prepare TGS_REQ_BODY
            # TGS_REQ_BODY = [kdc-options, cname*, realm, sname*, from*, till,
            #                 rtime, nonce, etype, addresses,
            #                 enc-authorization-data, additional-tickets]
            nonceC_TGS = random.StrongRandom().getrandbits(128)
            tgs_req_body = [dict(), None, 'TEST', S, 0,
                            time.time() + (5 * 3600), 0, nonceC_TGS, [ETYPE_AES_128_HMAC_SHA1_96, ETYPE_AES_256_HMAC_SHA1_96],
                            [], [], []]

            # Third, send KRB_TGS_REQ
            # KRB_TGS_REQ = [pvno, msg-type, padata, req-body]
            output('Client - Sent TGT and request to TGS for credentials',
                   'for server,', S)
            send(('krb_tgs_req',5, 12, [tgs_krb_ap_req], tgs_req_body), to = TGS)

            # await KRB_TGS_REP containing ticket and session key for server
            # KRB_TGS_REP = (pvno, msg-type, padata*, crealm, cname, ticket,
            #                enc-part)
            await(some(received(('krb_tgs_rep', 5, 13, tgs_padata, 'TEST', _C,
                                 ticket, tgs_enc_part), from_ = _TGS)))
            
            # decrypt the enc-part of the response
            tgsRepCipher = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC,
                                                       tgs_enc_part[:CIPHERS[paramsC_TGS[0]].block_size])
            ((paramsC_S, keyC_S), tgs_last_req, tgs_nonce, tgs_key_expiration, tgs_flags,
             tgs_authtime, tgs_starttime, tgs_endtime, tgs_renew_till,
             tgs_srealm, tgs_sname,
             tgs_caddr) = pickle.loads(unpad(tgsRepCipher.decrypt(tgs_enc_part[CIPHERS[paramsC_TGS[0]].block_size:])))

            # check that the returned nonce matches the one sent
            if tgs_nonce == nonceC_TGS:
                # check returned sname and srealm match those requested
                if tgs_sname == S and tgs_srealm == 'TEST':
                    # check host address field (caddr), if used
                    # MAY check the last-req and key_expiration fields to
                    # recommend client change password
                    output('Client - Acquired Ticket from TGS')
                    # output(decrypt(tgs_enc_part, keyC_TGS))
            else:
                keyC_S = None
                ticket = None

        if keyC_S != None:
            # send authentication request (KRB_AP_REQ) to application server
            # First, build Authenticator
            # Authenticator = [authenticator-vno, crealm, cname, cksum*, cusec,
            #                  ctime, subkey*, seq-number*, authorization-data*]
            ap_authenticator = [5, realm, C, None, None, time.time(), None, None, []]
            # Next, build and send the KRB_AP_REQ
            # KRB_AP_REQ = [pvno, msg-type, ap-options, ticket, authenticator]
            apReqIV = Random.new().read(CIPHERS[paramsC_S[0]].block_size)
            apReqCipher = CIPHERS[paramsC_S[0]].new(keyC_S, CIPHERS[paramsC_S[0]].MODE_CBC, apReqIV)
            send(('krb_ap_req', 5, 14, dict(), ticket,
                  apReqIV + apReqCipher.encrypt(pad(pickle.dumps(ap_authenticator)))), to = S)
            output('Client - Sent authentication request to server,', S)
        
def main():
    num_clients = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    num_servers = int(sys.argv[2]) if len(sys.argv) > 2 else 10
    C = new(RoleC, num = num_clients)
    S = new(RoleAppServer, num = num_servers)
    TGS = new(RoleTGS)
    AS = new(RoleAuthServer)
    client_keys = dict()
    for client in C:
        keyC_AS = Random.new().read(32)
        setup(client, ('TEST', S, AS, TGS, keyC_AS))
        client_keys[client] = keyC_AS
    as_server_keys = dict()
    tgs_server_keys = dict()
    for server in S:
        keyS_AS = Random.new().read(32)
        as_server_keys[server] = keyS_AS
        keyS_TGS = Random.new().read(32)
        tgs_server_keys[server] = keyS_TGS
        setup(server, (AS, TGS, keyS_AS, keyS_TGS))
    keyAS_TGS = Random.new().read(32)
    setup(AS, (C, S, TGS, client_keys, as_server_keys, keyAS_TGS))
    setup(TGS, (S, AS, keyAS_TGS, tgs_server_keys))
    start(AS)
    start(TGS)
    start(S)
    start(C)
