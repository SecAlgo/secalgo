# -*- generated by 1.0.12 -*-
import da
PatternExpr_206 = da.pat.TuplePattern([da.pat.ConstantPattern('msg02'), da.pat.BoundPattern('_BoundPattern209_'), da.pat.FreePattern('m')])
PatternExpr_214 = da.pat.BoundPattern('_BoundPattern215_')
PatternExpr_282 = da.pat.TuplePattern([da.pat.ConstantPattern('msg01'), da.pat.FreePattern('i'), da.pat.FreePattern('m')])
PatternExpr_291 = da.pat.FreePattern('A')
_config_object = {}
from sa.secalgoB import *

class RoleA(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleAReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_0', PatternExpr_206, sources=[PatternExpr_214], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, skA, B, pkB, **rest_366):
        super().setup(skA=skA, B=B, pkB=pkB, **rest_366)
        self._state.skA = skA
        self._state.B = B
        self._state.pkB = pkB
        at_fork()
        self._state.i = 1

    @dec_proto_run_timer
    def run(self):
        k = keygen('shared')
        self.send(('msg01', self._state.i, encrypt(sign(k, key=self._state.skA), key=self._state.pkB)), to=self._state.B)
        super()._label('_st_label_203', block=False)
        m = None

        def ExistentialOpExpr_204():
            nonlocal m
            for (_, (_, _, _BoundPattern222_), (_ConstantPattern224_, _BoundPattern226_, m)) in self._RoleAReceivedEvent_0:
                if (_BoundPattern222_ == self._state.B):
                    if (_ConstantPattern224_ == 'msg02'):
                        if (_BoundPattern226_ == self._state.i):
                            if True:
                                return True
            return False
        _st_label_203 = 0
        while (_st_label_203 == 0):
            _st_label_203 += 1
            if ExistentialOpExpr_204():
                _st_label_203 += 1
            else:
                super()._label('_st_label_203', block=True)
                _st_label_203 -= 1
        s = decrypt(m, key=k)
        self.output('DECRYPTED MESSAGE:', s)
        self._state.i += 1

class RoleB(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_0', PatternExpr_282, sources=[PatternExpr_291], destinations=None, timestamps=None, record_history=None, handlers=[self._RoleB_handler_281])])

    def setup(self, skB, pkA, **rest_366):
        super().setup(skB=skB, pkA=pkA, **rest_366)
        self._state.skB = skB
        self._state.pkA = pkA
        at_fork()
        self._state.terminate = False
        self._state.s = 'secret'

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_277', block=False)
        _st_label_277 = 0
        while (_st_label_277 == 0):
            _st_label_277 += 1
            if self._state.terminate:
                _st_label_277 += 1
            else:
                super()._label('_st_label_277', block=True)
                _st_label_277 -= 1

    def _RoleB_handler_281(self, i, m, A):
        k = verify(decrypt(m, key=self._state.skB), key=self._state.pkA)
        self.send(('msg02', i, encrypt(self._state.s, key=k)), to=A)
        self._state.terminate = True
    _RoleB_handler_281._labels = None
    _RoleB_handler_281._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        (skA, pkA) = keygen('public')
        (skB, pkB) = keygen('public')
        B = self.new(RoleB, (skB, pkA))
        A = self.new(RoleA, (skA, B, pkB))
        self._start(A)
        self._start(B)
