# -*- generated by 1.0.12 -*-
import da
PatternExpr_223 = da.pat.TuplePattern([da.pat.ConstantPattern('msg3'), da.pat.TuplePattern([da.pat.FreePattern('A'), da.pat.FreePattern('B'), da.pat.FreePattern('nA'), da.pat.FreePattern('encBS')])])
PatternExpr_237 = da.pat.BoundPattern('_BoundPattern238_')
PatternExpr_525 = da.pat.TuplePattern([da.pat.ConstantPattern('msg2'), da.pat.FreePattern('encBS')])
PatternExpr_532 = da.pat.BoundPattern('_BoundPattern533_')
PatternExpr_600 = da.pat.TuplePattern([da.pat.ConstantPattern('msg4'), da.pat.FreePattern('encAS')])
PatternExpr_607 = da.pat.BoundPattern('_BoundPattern608_')
PatternExpr_704 = da.pat.TuplePattern([da.pat.ConstantPattern('msg6'), da.pat.FreePattern('encBA')])
PatternExpr_711 = da.pat.BoundPattern('_BoundPattern712_')
PatternExpr_901 = da.pat.TuplePattern([da.pat.ConstantPattern('msg1'), da.pat.FreePattern('A')])
PatternExpr_908 = da.pat.BoundPattern('_BoundPattern909_')
PatternExpr_1021 = da.pat.TuplePattern([da.pat.ConstantPattern('msg5'), da.pat.FreePattern('encSB')])
PatternExpr_1028 = da.pat.BoundPattern('_BoundPattern1029_')
PatternExpr_1219 = da.pat.TuplePattern([da.pat.ConstantPattern('msg7'), da.pat.FreePattern('encAB')])
PatternExpr_1226 = da.pat.BoundPattern('_BoundPattern1227_')
_config_object = {}
import pickle, time, json
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random import random
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad
shared_method_loops = {'keygen': 60000, 'encrypt': 50000, 'decrypt': 200000, 'sign': 15000, 'verify': 15000, 'nonce': 60000}

class RoleS(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleSReceivedEvent_0', PatternExpr_223, sources=[PatternExpr_237], destinations=None, timestamps=None, record_history=None, handlers=[self._RoleS_handler_222])])

    def setup(self, kAS, kBS, **rest_1380):
        super().setup(kAS=kAS, kBS=kBS, **rest_1380)
        self._state.kAS = kAS
        self._state.kBS = kBS
        Random.atfork()
        self._state.results = []
        self._state.terminate = False

    def run(self):
        super()._label('_st_label_218', block=False)
        _st_label_218 = 0
        while (_st_label_218 == 0):
            _st_label_218 += 1
            if self._state.terminate:
                _st_label_218 += 1
            else:
                super()._label('_st_label_218', block=True)
                _st_label_218 -= 1

    def _RoleS_handler_222(self, A, B, nA, encBS):
        loops = shared_method_loops['decrypt']
        start_time = time.process_time()
        for i in range(loops):
            cipher = AES.new(self._state.kBS, AES.MODE_CBC, encBS[:AES.block_size])
            (A2, nB1) = pickle.loads(unpad(cipher.decrypt(encBS[AES.block_size:])))
        self._state.results.append(['decrypt', start_time, time.process_time(), loops])
        if (A2 == A):
            loops = shared_method_loops['keygen']
            start_time = time.process_time()
            for i in range(loops):
                kAB = Random.new().read(32)
            self._state.results.append(['keygen', start_time, time.process_time(), loops])
            loops = shared_method_loops['encrypt']
            start_time = time.process_time()
            for i in range(loops):
                ivB = Random.new().read(AES.block_size)
                cipherB = AES.new(self._state.kBS, AES.MODE_CBC, ivB)
                encSB = (ivB + cipherB.encrypt(pad(pickle.dumps((kAB, nB1, A)))))
            self._state.results.append(['encrypt', start_time, time.process_time(), loops])
            loops = shared_method_loops['encrypt']
            start_time = time.process_time()
            for i in range(loops):
                ivA = Random.new().read(AES.block_size)
                cipherA = AES.new(self._state.kAS, AES.MODE_CBC, ivA)
                encSA = (ivA + cipherA.encrypt(pad(pickle.dumps((nA, kAB, B, encSB)))))
            self._state.results.append(['encrypt', start_time, time.process_time(), loops])
            self.send(('msg4', encSA), to=A)
        for result in self._state.results:
            print(json.dumps(result))
        self._state.terminate = True
    _RoleS_handler_222._labels = None
    _RoleS_handler_222._notlabels = None

class RoleA(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleAReceivedEvent_0 = []
        self._RoleAReceivedEvent_1 = []
        self._RoleAReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_0', PatternExpr_525, sources=[PatternExpr_532], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_1', PatternExpr_600, sources=[PatternExpr_607], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_2', PatternExpr_704, sources=[PatternExpr_711], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, S, kAS, B, **rest_1380):
        super().setup(S=S, kAS=kAS, B=B, **rest_1380)
        self._state.S = S
        self._state.kAS = kAS
        self._state.B = B
        Random.atfork()
        self._state.results = []

    def run(self):
        self.send(('msg1', self._id), to=self._state.B)
        super()._label('_st_label_522', block=False)
        encBS = None

        def ExistentialOpExpr_523():
            nonlocal encBS
            for (_, (_, _, _BoundPattern540_), (_ConstantPattern542_, encBS)) in self._RoleAReceivedEvent_0:
                if (_BoundPattern540_ == self._state.B):
                    if (_ConstantPattern542_ == 'msg2'):
                        if True:
                            return True
            return False
        _st_label_522 = 0
        while (_st_label_522 == 0):
            _st_label_522 += 1
            if ExistentialOpExpr_523():
                _st_label_522 += 1
            else:
                super()._label('_st_label_522', block=True)
                _st_label_522 -= 1
        loops = shared_method_loops['nonce']
        start_time = time.process_time()
        for i in range(loops):
            nA = random.StrongRandom().getrandbits(128)
        self._state.results.append(['nonce', start_time, time.process_time(), loops])
        self.send(('msg3', (self._id, self._state.B, nA, encBS)), to=self._state.S)
        super()._label('_st_label_597', block=False)
        encAS = None

        def ExistentialOpExpr_598():
            nonlocal encAS
            for (_, (_, _, _BoundPattern615_), (_ConstantPattern617_, encAS)) in self._RoleAReceivedEvent_1:
                if (_BoundPattern615_ == self._state.S):
                    if (_ConstantPattern617_ == 'msg4'):
                        if True:
                            return True
            return False
        _st_label_597 = 0
        while (_st_label_597 == 0):
            _st_label_597 += 1
            if ExistentialOpExpr_598():
                _st_label_597 += 1
            else:
                super()._label('_st_label_597', block=True)
                _st_label_597 -= 1
        loops = shared_method_loops['decrypt']
        start_time = time.process_time()
        for i in range(loops):
            cipherAS = AES.new(self._state.kAS, AES.MODE_CBC, encAS[:AES.block_size])
            (nA2, kAB, B2, encSB) = pickle.loads(unpad(cipherAS.decrypt(encAS[AES.block_size:])))
        self._state.results.append(['decrypt', start_time, time.process_time(), loops])
        if ((nA2 == nA) and (B2 == self._state.B)):
            self.send(('msg5', encSB), to=self._state.B)
            super()._label('_st_label_701', block=False)
            encBA = None

            def ExistentialOpExpr_702():
                nonlocal encBA
                for (_, (_, _, _BoundPattern719_), (_ConstantPattern721_, encBA)) in self._RoleAReceivedEvent_2:
                    if (_BoundPattern719_ == self._state.B):
                        if (_ConstantPattern721_ == 'msg6'):
                            if True:
                                return True
                return False
            _st_label_701 = 0
            while (_st_label_701 == 0):
                _st_label_701 += 1
                if ExistentialOpExpr_702():
                    _st_label_701 += 1
                else:
                    super()._label('_st_label_701', block=True)
                    _st_label_701 -= 1
            loops = shared_method_loops['decrypt']
            start_time = time.process_time()
            for i in range(loops):
                cipherBA = AES.new(kAB, AES.MODE_CBC, encBA[:AES.block_size])
                nB = pickle.loads(unpad(cipherBA.decrypt(encBA[AES.block_size:])))
            self._state.results.append(['decrypt', start_time, time.process_time(), loops])
            loops = shared_method_loops['encrypt']
            start_time = time.process_time()
            for i in range(loops):
                ivAB = Random.new().read(AES.block_size)
                cipherAB = AES.new(kAB, AES.MODE_CBC, ivAB)
                encAB = (ivAB + cipherAB.encrypt(pad(pickle.dumps((nB - 1)))))
            self._state.results.append(['encrypt', start_time, time.process_time(), loops])
            self.send(('msg7', encAB), to=self._state.B)
            self.output('A - Key Exchange Complete')
        for result in self._state.results:
            print(json.dumps(result))

class RoleB(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleBReceivedEvent_1 = []
        self._RoleBReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_0', PatternExpr_901, sources=[PatternExpr_908], destinations=None, timestamps=None, record_history=None, handlers=[self._RoleB_handler_900]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_1', PatternExpr_1021, sources=[PatternExpr_1028], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_2', PatternExpr_1219, sources=[PatternExpr_1226], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, S, kBS, **rest_1380):
        super().setup(S=S, kBS=kBS, **rest_1380)
        self._state.S = S
        self._state.kBS = kBS
        Random.atfork()
        self._state.results = []
        self._state.terminate = False

    def run(self):
        super()._label('_st_label_896', block=False)
        _st_label_896 = 0
        while (_st_label_896 == 0):
            _st_label_896 += 1
            if self._state.terminate:
                _st_label_896 += 1
            else:
                super()._label('_st_label_896', block=True)
                _st_label_896 -= 1

    def _RoleB_handler_900(self, A):
        loops = shared_method_loops['nonce']
        start_time = time.process_time()
        for i in range(loops):
            nB1 = random.StrongRandom().getrandbits(128)
        self._state.results.append(['nonce', start_time, time.process_time(), loops])
        loops = shared_method_loops['encrypt']
        start_time = time.process_time()
        for i in range(loops):
            ivBS = Random.new().read(AES.block_size)
            cipherBS = AES.new(self._state.kBS, AES.MODE_CBC, ivBS)
            encBS = (ivBS + cipherBS.encrypt(pad(pickle.dumps((A, nB1)))))
        self._state.results.append(['encrypt', start_time, time.process_time(), loops])
        self.send(('msg2', encBS), to=A)
        super()._label('_st_label_1018', block=False)
        encSB = None

        def ExistentialOpExpr_1019():
            nonlocal encSB
            for (_, (_, _, _BoundPattern1036_), (_ConstantPattern1038_, encSB)) in self._RoleBReceivedEvent_1:
                if (_BoundPattern1036_ == A):
                    if (_ConstantPattern1038_ == 'msg5'):
                        if True:
                            return True
            return False
        _st_label_1018 = 0
        while (_st_label_1018 == 0):
            _st_label_1018 += 1
            if ExistentialOpExpr_1019():
                _st_label_1018 += 1
            else:
                super()._label('_st_label_1018', block=True)
                _st_label_1018 -= 1
        loops = shared_method_loops['decrypt']
        start_time = time.process_time()
        for i in range(loops):
            cipherBS = AES.new(self._state.kBS, AES.MODE_CBC, encSB[:AES.block_size])
            (kAB, nB12, A2) = pickle.loads(unpad(cipherBS.decrypt(encSB[AES.block_size:])))
        self._state.results.append(['decrypt', start_time, time.process_time(), loops])
        if ((nB12 == nB1) and (A2 == A)):
            loops = shared_method_loops['nonce']
            start_time = time.process_time()
            for i in range(loops):
                nB2 = random.StrongRandom().getrandbits(128)
            self._state.results.append(['nonce', start_time, time.process_time(), loops])
            loops = shared_method_loops['encrypt']
            start_time = time.process_time()
            for i in range(loops):
                ivBA = Random.new().read(AES.block_size)
                cipherBA = AES.new(kAB, AES.MODE_CBC, ivBA)
                encBA = (ivBA + cipherBA.encrypt(pad(pickle.dumps(nB2))))
            self._state.results.append(['encrypt', start_time, time.process_time(), loops])
            self.send(('msg6', encBA), to=A)
            super()._label('_st_label_1216', block=False)
            encAB = None

            def ExistentialOpExpr_1217():
                nonlocal encAB
                for (_, (_, _, _BoundPattern1234_), (_ConstantPattern1236_, encAB)) in self._RoleBReceivedEvent_2:
                    if (_BoundPattern1234_ == A):
                        if (_ConstantPattern1236_ == 'msg7'):
                            if True:
                                return True
                return False
            _st_label_1216 = 0
            while (_st_label_1216 == 0):
                _st_label_1216 += 1
                if ExistentialOpExpr_1217():
                    _st_label_1216 += 1
                else:
                    super()._label('_st_label_1216', block=True)
                    _st_label_1216 -= 1
            loops = shared_method_loops['decrypt']
            start_time = time.process_time()
            for i in range(loops):
                cipherAB = AES.new(kAB, AES.MODE_CBC, encAB[:AES.block_size])
                nB22 = pickle.loads(unpad(cipherAB.decrypt(encAB[AES.block_size:])))
            self._state.results.append(['decrypt', start_time, time.process_time(), loops])
            if (nB22 == (nB2 - 1)):
                self.output('B - Key Exchange Complete')
        for result in self._state.results:
            print(json.dumps(result))
        self._state.terminate = True
    _RoleB_handler_900._labels = None
    _RoleB_handler_900._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        kAS = Random.new().read(32)
        kBS = Random.new().read(32)
        S = self.new(RoleS, (kAS, kBS))
        B = self.new(RoleB, (S, kBS))
        A = self.new(RoleA, (S, kAS, B))
        self._start(S)
        self._start(B)
        self._start(A)
