# -*- generated by 1.0.12 -*-
import da
PatternExpr_204 = da.pat.TuplePattern([da.pat.ConstantPattern('msg02'), da.pat.BoundPattern('_BoundPattern207_'), da.pat.TuplePattern([da.pat.FreePattern('A'), da.pat.BoundPattern('_BoundPattern210_'), da.pat.FreePattern('tA'), da.pat.FreePattern('sigA')]), da.pat.TuplePattern([da.pat.BoundPattern('_BoundPattern216_'), da.pat.FreePattern('pkB'), da.pat.FreePattern('tB'), da.pat.FreePattern('sigB')])])
PatternExpr_226 = da.pat.BoundPattern('_BoundPattern227_')
PatternExpr_359 = da.pat.TuplePattern([da.pat.ConstantPattern('msg03'), da.pat.FreePattern('i'), da.pat.TuplePattern([da.pat.FreePattern('A'), da.pat.FreePattern('pkA'), da.pat.FreePattern('tA'), da.pat.FreePattern('sigA')]), da.pat.TuplePattern([da.pat.FreePattern('B'), da.pat.BoundPattern('_BoundPattern375_'), da.pat.FreePattern('tB'), da.pat.FreePattern('sigB')]), da.pat.FreePattern('encKey')])
PatternExpr_385 = da.pat.FreePattern('A')
PatternExpr_475 = da.pat.TuplePattern([da.pat.ConstantPattern('msg01'), da.pat.FreePattern('i'), da.pat.FreePattern('A'), da.pat.FreePattern('B')])
PatternExpr_486 = da.pat.BoundPattern('_BoundPattern487_')
_config_object = {}
import sys, time
from sa.secalgoB import *
configure(verify_returns='bool')

class roleA(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._roleAReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_roleAReceivedEvent_0', PatternExpr_204, sources=[PatternExpr_226], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, B, S, skA, pkA, pkS, **rest_644):
        super().setup(B=B, S=S, skA=skA, pkA=pkA, pkS=pkS, **rest_644)
        self._state.B = B
        self._state.S = S
        self._state.skA = skA
        self._state.pkA = pkA
        self._state.pkS = pkS
        at_fork()
        self._state.i = 1

    @dec_proto_run_timer
    def run(self):
        self.send(('msg01', self._state.i, self._id, self._state.B), to=self._state.S)
        super()._label('_st_label_201', block=False)
        A = pkB = sigA = tB = tA = sigB = None

        def ExistentialOpExpr_202():
            nonlocal A, pkB, sigA, tB, tA, sigB
            for (_, (_, _, _BoundPattern234_), (_ConstantPattern236_, _BoundPattern238_, (A, _BoundPattern241_, tA, sigA), (_BoundPattern245_, pkB, tB, sigB))) in self._roleAReceivedEvent_0:
                if (_BoundPattern234_ == self._state.S):
                    if (_ConstantPattern236_ == 'msg02'):
                        if (_BoundPattern238_ == self._state.i):
                            if (_BoundPattern241_ == self._state.pkA):
                                if (_BoundPattern245_ == self._state.B):
                                    if (A == self._id):
                                        return True
            return False
        _st_label_201 = 0
        while (_st_label_201 == 0):
            _st_label_201 += 1
            if ExistentialOpExpr_202():
                _st_label_201 += 1
            else:
                super()._label('_st_label_201', block=True)
                _st_label_201 -= 1
        if (verify(((A, self._state.pkA, tA), sigA), key=self._state.pkS) and verify(((self._state.B, pkB, tB), sigB), key=self._state.pkS)):
            kAB = keygen('shared')
            tAB = time.time()
            self.send(('msg03', self._state.i, (A, self._state.pkA, tA, sigA), (self._state.B, pkB, tB, sigB), encrypt(((kAB, tAB), sign((kAB, tAB), key=self._state.skA)), key=pkB)), to=self._state.B)
            self.output('Initiator: Key Exchange Complete')
        else:
            self.output('Initiator: Could not verify certificates')
        self._state.i += 1

class roleB(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_roleBReceivedEvent_0', PatternExpr_359, sources=[PatternExpr_385], destinations=None, timestamps=None, record_history=None, handlers=[self._roleB_handler_358])])

    def setup(self, S, skB, pkB, pkS, **rest_644):
        super().setup(S=S, skB=skB, pkB=pkB, pkS=pkS, **rest_644)
        self._state.S = S
        self._state.skB = skB
        self._state.pkB = pkB
        self._state.pkS = pkS
        at_fork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_354', block=False)
        _st_label_354 = 0
        while (_st_label_354 == 0):
            _st_label_354 += 1
            if self._state.terminate:
                _st_label_354 += 1
            else:
                super()._label('_st_label_354', block=True)
                _st_label_354 -= 1

    def _roleB_handler_358(self, i, A, pkA, tA, sigA, B, tB, sigB, encKey):
        if (verify(((A, pkA, tA), sigA), key=self._state.pkS) and verify(((B, self._state.pkB, tB), sigB), key=self._state.pkS) and (B == self._id)):
            ((kAB, tAB), sigAB) = decrypt(encKey, key=self._state.skB)
            if verify(((kAB, tAB), sigAB), key=pkA):
                self.output('Recipient: Key Exchange Complete')
            else:
                self.output('Recipient: Could not verify signature on shared key')
        else:
            self.output('Recipient: Could not verify certificates')
        self._state.terminate = True
    _roleB_handler_358._labels = None
    _roleB_handler_358._notlabels = None

class roleS(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_roleSReceivedEvent_0', PatternExpr_475, sources=[PatternExpr_486], destinations=None, timestamps=None, record_history=None, handlers=[self._roleS_handler_474])])

    def setup(self, skS, pkS, client_keys, **rest_644):
        super().setup(skS=skS, pkS=pkS, client_keys=client_keys, **rest_644)
        self._state.skS = skS
        self._state.pkS = pkS
        self._state.client_keys = client_keys
        at_fork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_470', block=False)
        _st_label_470 = 0
        while (_st_label_470 == 0):
            _st_label_470 += 1
            if self._state.terminate:
                _st_label_470 += 1
            else:
                super()._label('_st_label_470', block=True)
                _st_label_470 -= 1

    def _roleS_handler_474(self, i, A, B):
        pkA = [x for (p, x) in self._state.client_keys if (p == A)].pop()
        pkB = [x for (p, x) in self._state.client_keys if (p == B)].pop()
        tA = tB = time.time()
        self.send(('msg02', i, (A, pkA, tA, sign((A, pkA, tA), key=self._state.skS)), (B, pkB, tB, sign((B, pkB, tB), key=self._state.skS))), to=A)
        self.output('Server: Certificates Sent')
        self._state.terminate = True
    _roleS_handler_474._labels = None
    _roleS_handler_474._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        (skS, pkS) = keygen('public')
        (skA, pkA) = keygen('public')
        (skB, pkB) = keygen('public')
        S = self.new(roleS)
        B = self.new(roleB, (S, skB, pkB, pkS))
        A = self.new(roleA, (B, S, skA, pkA, pkS))
        self._setup(S, (skS, pkS, [(A, pkA), (B, pkB)]))
        self._start(S)
        self._start(B)
        self._start(A)
