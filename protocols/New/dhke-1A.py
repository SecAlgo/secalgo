# -*- generated by 1.0.12 -*-
import da
PatternExpr_235 = da.pat.TuplePattern([da.pat.ConstantPattern('msg2'), da.pat.BoundPattern('_BoundPattern238_'), da.pat.FreePattern('dh_Y'), da.pat.FreePattern('k'), da.pat.FreePattern('m'), da.pat.FreePattern('certB')])
PatternExpr_249 = da.pat.FreePattern('B')
PatternExpr_352 = da.pat.TuplePattern([da.pat.ConstantPattern('msg1'), da.pat.FreePattern('i'), da.pat.FreePattern('dh_X'), da.pat.FreePattern('m'), da.pat.FreePattern('certA')])
PatternExpr_365 = da.pat.FreePattern('A')
PatternExpr_449 = da.pat.TuplePattern([da.pat.ConstantPattern('msg3'), da.pat.BoundPattern('_BoundPattern452_'), da.pat.FreePattern('m2')])
PatternExpr_457 = da.pat.FreePattern('A')
_config_object = {}
from sa.secalgoB import *
import random
from Crypto.Random.random import StrongRandom
from Crypto.Hash import SHA256
configure(verify_returns='bool')

class RoleA(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleAReceivedEvent_0 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleAReceivedEvent_0', PatternExpr_235, sources=[PatternExpr_249], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, skA, pkA, B, pkB, certA, pkSigT, **rest_685):
        super().setup(skA=skA, pkA=pkA, B=B, pkB=pkB, certA=certA, pkSigT=pkSigT, **rest_685)
        self._state.skA = skA
        self._state.pkA = pkA
        self._state.B = B
        self._state.pkB = pkB
        self._state.certA = certA
        self._state.pkSigT = pkSigT
        at_fork()
        self._state.i = 1

    @dec_proto_run_timer
    def run(self):
        (dh_x, dh_X, _, _) = keygen('dh', dh_p=self._state.pkA[2], dh_g=self._state.pkA[1])
        self.send(('msg1', self._state.i, dh_X, sign((dh_X, self._state.B), key=self._state.skA), self._state.certA), to=self._state.B)
        super()._label('_st_label_232', block=False)
        B = m = dh_Y = certB = k = None

        def ExistentialOpExpr_233():
            nonlocal B, m, dh_Y, certB, k
            for (_, (_, _, self._state.B), (_ConstantPattern259_, _BoundPattern261_, dh_Y, k, m, certB)) in self._RoleAReceivedEvent_0:
                if (_ConstantPattern259_ == 'msg2'):
                    if (_BoundPattern261_ == self._state.i):
                        if True:
                            return True
            return False
        _st_label_232 = 0
        while (_st_label_232 == 0):
            _st_label_232 += 1
            if ExistentialOpExpr_233():
                _st_label_232 += 1
            else:
                super()._label('_st_label_232', block=True)
                _st_label_232 -= 1
        if verify(((self._state.B, self._state.pkB), certB), key=self._state.pkSigT):
            if verify(((dh_X, dh_Y, k, self._id), m), key=self._state.pkB[0]):
                kAB = key_derivation(dh_Y, dh_x, self._state.pkA[2])
                self.send(('msg3', self._state.i, BitGen(kAB)), to=self._state.B)
                self.output('A - Authenticated Exchange of Key Material Complete')
        self._state.i += 1

class RoleB(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._RoleBReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_0', PatternExpr_352, sources=[PatternExpr_365], destinations=None, timestamps=None, record_history=None, handlers=[self._RoleB_handler_351]), da.pat.EventPattern(da.pat.ReceivedEvent, '_RoleBReceivedEvent_1', PatternExpr_449, sources=[PatternExpr_457], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, skB, pkB, pkA, certB, pkSigT, **rest_685):
        super().setup(skB=skB, pkB=pkB, pkA=pkA, certB=certB, pkSigT=pkSigT, **rest_685)
        self._state.skB = skB
        self._state.pkB = pkB
        self._state.pkA = pkA
        self._state.certB = certB
        self._state.pkSigT = pkSigT
        at_fork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_347', block=False)
        _st_label_347 = 0
        while (_st_label_347 == 0):
            _st_label_347 += 1
            if self._state.terminate:
                _st_label_347 += 1
            else:
                super()._label('_st_label_347', block=True)
                _st_label_347 -= 1

    def _RoleB_handler_351(self, i, dh_X, m, certA, A):
        (dh_y, dh_Y, _, _) = keygen('dh', dh_p=self._state.pkA[2], dh_g=self._state.pkA[1])
        if verify(((A, self._state.pkA), certA), key=self._state.pkSigT):
            if verify(((dh_X, self._id), m), key=self._state.pkA[0]):
                k = StrongRandom().randint(1, 100)
                self.send(('msg2', i, dh_Y, k, sign((dh_X, dh_Y, k, A), key=self._state.skB), self._state.certB), to=A)
                kAB = key_derivation(dh_X, dh_y, self._state.pkA[2])
                super()._label('_st_label_446', block=False)
                m2 = A = None

                def ExistentialOpExpr_447():
                    nonlocal m2, A
                    for (_, (_, _, A), (_ConstantPattern467_, _BoundPattern469_, m2)) in self._RoleBReceivedEvent_1:
                        if (_ConstantPattern467_ == 'msg3'):
                            if (_BoundPattern469_ == i):
                                if True:
                                    return True
                    return False
                _st_label_446 = 0
                while (_st_label_446 == 0):
                    _st_label_446 += 1
                    if ExistentialOpExpr_447():
                        _st_label_446 += 1
                    else:
                        super()._label('_st_label_446', block=True)
                        _st_label_446 -= 1
                if (BitGen(kAB) == m2):
                    self.output('B - Authenticated Exchange of Key Material Complete')
        self._state.terminate = True
    _RoleB_handler_351._labels = None
    _RoleB_handler_351._notlabels = None

def BitGen(x):
    random.seed(x)
    return random.getrandbits(256)

def key_derivation(public, private, mod_p):
    shared_secret = pow(public, private, mod_p)
    ss_length_bits = shared_secret.bit_length()
    ss_length_bytes = (ss_length_bits // 8)
    if (not ((ss_length_bits % 8) == 0)):
        ss_length_bytes += 1
    ss_as_bytes = shared_secret.to_bytes(ss_length_bytes, byteorder='little')
    new_key = SHA256.new(ss_as_bytes).digest()
    return new_key

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        (skSigA, pkSigA) = keygen('public')
        (skSigB, pkSigB) = keygen('public')
        (skSigT, pkSigT) = keygen('public')
        dh_grpA = keygen('dh', 1)
        dh_grpB = keygen('dh', 1)
        skA = skSigA
        skB = skSigB
        pkA = (pkSigA, dh_grpA[2], dh_grpA[3])
        pkB = (pkSigB, dh_grpB[2], dh_grpB[3])
        B = self.new(RoleB)
        A = self.new(RoleA)
        certA = sign((A, pkA), key=skSigT)
        certB = sign((B, pkB), key=skSigT)
        self._setup(B, (skB, pkB, pkA, certB, pkSigT))
        self._setup(A, (skA, pkA, B, pkB, certA, pkSigT))
        self._start(B)
        self._start(A)
