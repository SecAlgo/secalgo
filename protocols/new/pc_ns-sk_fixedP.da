"""
Needham-Schroeder Symmetric Key Key Exhange Protocol
Written by Christopher Kane

Original Source:
R. Needham and M. Schroeder. "Authentication revisited". 
Operating Systems Review, 21(7), January 1987.

Immediate Source:
Security Protocol Open Repository
http://www.lsv.fr/Software/spore/nssk_amended.html

Protocol Diagram:
  (1) A -> B : A
  (2) B -> A : enc((A, nB1), kBS)
  (3) A -> S : (A, B, nA, enc((A, nB1), kBS))
  (4) S -> A : enc((nA, kAB, B, enc((kAB, nB1, A), kBS)), kAS)
  (5) A -> B : enc((kAB, nB1, A), kBS)
  (6) B -> A : enc(nB2, kAB)
  (7) A -> B : enc(nB2 - 1, kAB)
"""

import pickle, time, json
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random import random
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad

pickle_loops = 2000000

class RoleS (process):
    def setup(kAS, kBS):
        Random.atfork()
        self.results = []
        self.terminate = False

    def run():
        await(terminate)

    def receive(msg=('msg3', (A, B, nA, encBS)), from_ = _A):

        cipher = AES.new(kBS, AES.MODE_CBC, encBS[:AES.block_size])
        serial_pt = unpad(cipher.decrypt(encBS[AES.block_size:]))
        loops = pickle_loops
        start_time = time.process_time()
        for i in range(loops):
            A2, nB1 = pickle.loads(serial_pt)
        results.append(['pickle.loads', 'sym_decrypt', start_time,
                        time.process_time(), loops])
        
        if A2 == A:
            kAB = Random.new().read(32)
            
            loops = pickle_loops
            start_time = time.process_time()
            for i in range(loops):
                serial_pt = pickle.dumps((kAB, nB1, A))
            results.append(['pickle.dumps', 'sym_encrypt', start_time,
                            time.process_time(), loops])
            ivB = Random.new().read(AES.block_size)
            cipherB = AES.new(kBS, AES.MODE_CBC, ivB)
            encSB = ivB + cipherB.encrypt(pad(serial_pt))
            
            loops = pickle_loops
            start_time = time.process_time()
            for i in range(loops):
                serial_pt = pickle.dumps((nA, kAB, B, encSB))
            results.append(['pickle.dumps', 'sym_encrypt', start_time,
                            time.process_time(), loops])
            ivA = Random.new().read(AES.block_size)
            cipherA = AES.new(kAS, AES.MODE_CBC, ivA)
            encSA = ivA + cipherA.encrypt(pad(serial_pt))
            
            send(('msg4', encSA), to = A)
        for result in self.results:
            print(json.dumps(result))
        terminate = True

class RoleA (process):
    def setup(S, kAS, B):
        Random.atfork()
        self.results = []

    def run():
        send(('msg1', self), to = B)
        await(some(received(('msg2', encBS), from_ = _B)))

        nA = random.StrongRandom().getrandbits(128)
                
        send(('msg3', (self, B, nA, encBS)), to = S)
        await(some(received(('msg4', encAS), from_ = _S)))

        cipherAS = AES.new(kAS, AES.MODE_CBC, encAS[:AES.block_size])
        serial_pt = unpad(cipherAS.decrypt(encAS[AES.block_size:]))
        loops = pickle_loops        
        start_time = time.process_time()
        for i in range(loops):
            nA2, kAB, B2, encSB = pickle.loads(serial_pt)
        results.append(['pickle.loads', 'sym_decrypt', start_time,
                        time.process_time(), loops])
        
        if nA2 == nA and B2 == B:
            send(('msg5', encSB), to = B)
            await(some(received(('msg6', encBA), from_ = _B)))

            cipherBA = AES.new(kAB, AES.MODE_CBC, encBA[:AES.block_size])
            serial_pt = unpad(cipherBA.decrypt(encBA[AES.block_size:]))
            loops = pickle_loops
            start_time = time.process_time()
            for i in range(loops):
                nB = pickle.loads(serial_pt)
            results.append(['pickle.loads', 'sym_decrypt', start_time,
                            time.process_time(), loops])


            loops = pickle_loops
            start_time = time.process_time()
            for i in range(loops):
                serial_pt = pickle.dumps((nB - 1))
            results.append(['pickle.dumps', 'sym_encrypt', start_time,
                            time.process_time(), loops])
            ivAB = Random.new().read(AES.block_size)
            cipherAB = AES.new(kAB, AES.MODE_CBC, ivAB)
            encAB = ivAB + cipherAB.encrypt(pad(serial_pt))
            

            send(('msg7', encAB), to = B)
            output('A - Key Exchange Complete')
        for result in self.results:
            print(json.dumps(result))

class RoleB (process):
    def setup(S, kBS):
        Random.atfork()
        self.results = []
        self.terminate = False
    
    def run():
        await(terminate)

    def receive(msg=('msg1', A), from_ = _A):
        nB1 = random.StrongRandom().getrandbits(128)

        loops = pickle_loops
        start_time = time.process_time()
        for i in range(loops):
            serial_pt = pickle.dumps((A, nB1))
        results.append(['pickle.dumps', 'sym_encrypt', start_time,
                        time.process_time(), loops])
        ivBS = Random.new().read(AES.block_size)
        cipherBS = AES.new(kBS, AES.MODE_CBC, ivBS)
        encBS = ivBS + cipherBS.encrypt(pad(serial_pt))
                
        
        send(('msg2', encBS), to = A)
        await(some(received(('msg5', encSB), from_ = _A)))

        cipherBS = AES.new(kBS, AES.MODE_CBC, encSB[:AES.block_size])
        serial_pt = unpad(cipherBS.decrypt(encSB[AES.block_size:]))
        loops = pickle_loops
        start_time = time.process_time()
        for i in range(loops):
            kAB, nB12, A2 = pickle.loads(serial_pt)
        results.append(['pickle.loads', 'sym_decrypt', start_time,
                        time.process_time(), loops])

        if nB12 == nB1 and A2 == A:
            nB2 = random.StrongRandom().getrandbits(128)

            loops = pickle_loops
            start_time = time.process_time()
            for i in range(loops):
                serial_pt = pickle.dumps(nB2)
            results.append(['pickle.dumps', 'sym_encrypt', start_time,
                            time.process_time(), loops])
            ivBA = Random.new().read(AES.block_size)
            cipherBA = AES.new(kAB, AES.MODE_CBC, ivBA)
            encBA = ivBA + cipherBA.encrypt(pad(serial_pt))

            send(('msg6', encBA), to = A)
            await(some(received(('msg7', encAB), from_ = _A)))

            cipherAB = AES.new(kAB, AES.MODE_CBC, encAB[:AES.block_size])
            serial_pt = unpad(cipherAB.decrypt(encAB[AES.block_size:]))
            loops = pickle_loops
            start_time = time.process_time()
            for i in range(loops):
                nB22 = pickle.loads(serial_pt)
            results.append(['pickle.loads', 'sym_decrypt', start_time,
                            time.process_time(), loops])
            
            if nB22 == (nB2 - 1):
                output('B - Key Exchange Complete')
        for result in self.results:
            print(json.dumps(result))
        terminate = True
        
def main():
    kAS = Random.new().read(32)
    kBS = Random.new().read(32)
    S = new(RoleS, (kAS, kBS))
    B = new(RoleB, (S, kBS))
    A = new(RoleA, (S, kAS, B))
    start(S)
    start(B)
    start(A)
