# -*- generated by 1.0.12 -*-
import da
PatternExpr_192 = da.pat.TuplePattern([da.pat.ConstantPattern('msg1'), da.pat.FreePattern('i'), da.pat.TuplePattern([da.pat.FreePattern('A'), da.pat.FreePattern('B')])])
PatternExpr_204 = da.pat.BoundPattern('_BoundPattern205_')
PatternExpr_238 = da.pat.TuplePattern([da.pat.ConstantPattern('msg4'), da.pat.FreePattern('i'), da.pat.TuplePattern([da.pat.FreePattern('B'), da.pat.FreePattern('A')])])
PatternExpr_250 = da.pat.BoundPattern('_BoundPattern251_')
PatternExpr_323 = da.pat.TuplePattern([da.pat.ConstantPattern('msg2'), da.pat.BoundPattern('_BoundPattern326_'), da.pat.FreePattern('sigS')])
PatternExpr_331 = da.pat.BoundPattern('_BoundPattern332_')
PatternExpr_383 = da.pat.TuplePattern([da.pat.ConstantPattern('msg6'), da.pat.BoundPattern('_BoundPattern386_'), da.pat.FreePattern('encBA')])
PatternExpr_391 = da.pat.BoundPattern('_BoundPattern392_')
PatternExpr_470 = da.pat.TuplePattern([da.pat.ConstantPattern('msg3'), da.pat.FreePattern('i'), da.pat.FreePattern('encAB')])
PatternExpr_479 = da.pat.FreePattern('A')
PatternExpr_509 = da.pat.TuplePattern([da.pat.ConstantPattern('msg5'), da.pat.BoundPattern('_BoundPattern512_'), da.pat.FreePattern('sigS')])
PatternExpr_517 = da.pat.BoundPattern('_BoundPattern518_')
PatternExpr_570 = da.pat.TuplePattern([da.pat.ConstantPattern('msg7'), da.pat.BoundPattern('_BoundPattern573_'), da.pat.FreePattern('encAB2')])
PatternExpr_578 = da.pat.BoundPattern('_BoundPattern579_')
_config_object = {}
import sys
from sa.secalgoB import *

class roleS(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_roleSReceivedEvent_0', PatternExpr_192, sources=[PatternExpr_204], destinations=None, timestamps=None, record_history=None, handlers=[self._roleS_handler_191]), da.pat.EventPattern(da.pat.ReceivedEvent, '_roleSReceivedEvent_1', PatternExpr_238, sources=[PatternExpr_250], destinations=None, timestamps=None, record_history=None, handlers=[self._roleS_handler_237])])

    def setup(self, skS, clientKeys, loops, **rest_701):
        super().setup(skS=skS, clientKeys=clientKeys, loops=loops, **rest_701)
        self._state.skS = skS
        self._state.clientKeys = clientKeys
        self._state.loops = loops
        at_fork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_187', block=False)
        _st_label_187 = 0
        while (_st_label_187 == 0):
            _st_label_187 += 1
            if self._state.terminate:
                _st_label_187 += 1
            else:
                super()._label('_st_label_187', block=True)
                _st_label_187 -= 1

    def _roleS_handler_191(self, i, A, B):
        pkB = [x for (p, x) in self._state.clientKeys if (p == B)].pop()
        self.send(('msg2', i, sign((B, pkB), key=self._state.skS)), to=A)
    _roleS_handler_191._labels = None
    _roleS_handler_191._notlabels = None

    def _roleS_handler_237(self, i, B, A):
        pkA = [x for (p, x) in self._state.clientKeys if (p == A)].pop()
        self.send(('msg5', i, sign((A, pkA), key=self._state.skS)), to=B)
        self._state.terminate = True
    _roleS_handler_237._labels = None
    _roleS_handler_237._notlabels = None

class roleA(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._roleAReceivedEvent_0 = []
        self._roleAReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_roleAReceivedEvent_0', PatternExpr_323, sources=[PatternExpr_331], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_roleAReceivedEvent_1', PatternExpr_383, sources=[PatternExpr_391], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, skA, S, pkS, B, loops, **rest_701):
        super().setup(skA=skA, S=S, pkS=pkS, B=B, loops=loops, **rest_701)
        self._state.skA = skA
        self._state.S = S
        self._state.pkS = pkS
        self._state.B = B
        self._state.loops = loops
        at_fork()
        self._state.i = 1

    @dec_proto_run_timer
    def run(self):
        self.send(('msg1', self._state.i, (self._id, self._state.B)), to=self._state.S)
        super()._label('_st_label_320', block=False)
        sigS = pkB = None

        def ExistentialOpExpr_321():
            nonlocal sigS, pkB
            for (_, (_, _, _BoundPattern339_), (_ConstantPattern341_, _BoundPattern343_, sigS)) in self._roleAReceivedEvent_0:
                if (_BoundPattern339_ == self._state.S):
                    if (_ConstantPattern341_ == 'msg2'):
                        if (_BoundPattern343_ == self._state.i):

                            def ExistentialOpExpr_346(sigS):
                                nonlocal pkB
                                for (_BoundPattern349_, pkB) in [verify(sigS, key=self._state.pkS)]:
                                    if (_BoundPattern349_ == self._state.B):
                                        if True:
                                            return True
                                return False
                            if ExistentialOpExpr_346(sigS=sigS):
                                return True
            return False
        _st_label_320 = 0
        while (_st_label_320 == 0):
            _st_label_320 += 1
            if ExistentialOpExpr_321():
                _st_label_320 += 1
            else:
                super()._label('_st_label_320', block=True)
                _st_label_320 -= 1
        nA = nonce()
        self.send(('msg3', self._state.i, encrypt((nA, self._id), key=pkB)), to=self._state.B)
        super()._label('_st_label_380', block=False)
        nB = encBA = None

        def ExistentialOpExpr_381():
            nonlocal nB, encBA
            for (_, (_, _, _BoundPattern399_), (_ConstantPattern401_, _BoundPattern403_, encBA)) in self._roleAReceivedEvent_1:
                if (_BoundPattern399_ == self._state.B):
                    if (_ConstantPattern401_ == 'msg6'):
                        if (_BoundPattern403_ == self._state.i):

                            def ExistentialOpExpr_406(encBA):
                                nonlocal nB
                                for (_BoundPattern409_, nB, _BoundPattern412_) in [decrypt(encBA, key=self._state.skA)]:
                                    if (_BoundPattern409_ == nA):
                                        if (_BoundPattern412_ == self._state.B):
                                            if True:
                                                return True
                                return False
                            if ExistentialOpExpr_406(encBA=encBA):
                                return True
            return False
        _st_label_380 = 0
        while (_st_label_380 == 0):
            _st_label_380 += 1
            if ExistentialOpExpr_381():
                _st_label_380 += 1
            else:
                super()._label('_st_label_380', block=True)
                _st_label_380 -= 1
        self.send(('msg7', self._state.i, encrypt(nB, key=pkB)), to=self._state.B)
        self.output('A authenticated B')
        self._state.i += 1

class roleB(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._roleBReceivedEvent_1 = []
        self._roleBReceivedEvent_2 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_roleBReceivedEvent_0', PatternExpr_470, sources=[PatternExpr_479], destinations=None, timestamps=None, record_history=None, handlers=[self._roleB_handler_469]), da.pat.EventPattern(da.pat.ReceivedEvent, '_roleBReceivedEvent_1', PatternExpr_509, sources=[PatternExpr_517], destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_roleBReceivedEvent_2', PatternExpr_570, sources=[PatternExpr_578], destinations=None, timestamps=None, record_history=True, handlers=[])])

    def setup(self, skB, S, pkS, loops, **rest_701):
        super().setup(skB=skB, S=S, pkS=pkS, loops=loops, **rest_701)
        self._state.skB = skB
        self._state.S = S
        self._state.pkS = pkS
        self._state.loops = loops
        at_fork()
        self._state.terminate = False

    @dec_proto_run_timer
    def run(self):
        self._state.terminate = False
        super()._label('_st_label_465', block=False)
        _st_label_465 = 0
        while (_st_label_465 == 0):
            _st_label_465 += 1
            if self._state.terminate:
                _st_label_465 += 1
            else:
                super()._label('_st_label_465', block=True)
                _st_label_465 -= 1

    def _roleB_handler_469(self, i, encAB, A):
        nA = None

        def ExistentialOpExpr_483():
            nonlocal nA
            for (nA, _BoundPattern488_) in [decrypt(encAB, key=self._state.skB)]:
                if (_BoundPattern488_ == A):
                    if True:
                        return True
            return False
        if ExistentialOpExpr_483():
            self.send(('msg4', i, (self._id, A)), to=self._state.S)
            super()._label('_st_label_506', block=False)
            pkA = sigS = None

            def ExistentialOpExpr_507():
                nonlocal pkA, sigS
                for (_, (_, _, _BoundPattern525_), (_ConstantPattern527_, _BoundPattern529_, sigS)) in self._roleBReceivedEvent_1:
                    if (_BoundPattern525_ == self._state.S):
                        if (_ConstantPattern527_ == 'msg5'):
                            if (_BoundPattern529_ == i):

                                def ExistentialOpExpr_532(sigS):
                                    nonlocal pkA
                                    for (_BoundPattern535_, pkA) in [verify(sigS, key=self._state.pkS)]:
                                        if (_BoundPattern535_ == A):
                                            if True:
                                                return True
                                    return False
                                if ExistentialOpExpr_532(sigS=sigS):
                                    return True
                return False
            _st_label_506 = 0
            while (_st_label_506 == 0):
                _st_label_506 += 1
                if ExistentialOpExpr_507():
                    _st_label_506 += 1
                else:
                    super()._label('_st_label_506', block=True)
                    _st_label_506 -= 1
        nB = nonce()
        self.send(('msg6', i, encrypt((nA, nB, self._id), key=pkA)), to=A)
        super()._label('_st_label_567', block=False)
        encAB2 = None

        def ExistentialOpExpr_568():
            nonlocal encAB2
            for (_, (_, _, _BoundPattern586_), (_ConstantPattern588_, _BoundPattern590_, encAB2)) in self._roleBReceivedEvent_2:
                if (_BoundPattern586_ == A):
                    if (_ConstantPattern588_ == 'msg7'):
                        if (_BoundPattern590_ == i):
                            if (decrypt(encAB2, key=self._state.skB) == nB):
                                return True
            return False
        _st_label_567 = 0
        while (_st_label_567 == 0):
            _st_label_567 += 1
            if ExistentialOpExpr_568():
                _st_label_567 += 1
            else:
                super()._label('_st_label_567', block=True)
                _st_label_567 -= 1
        self.output('B authenticated A')
        self._state.terminate = True
    _roleB_handler_469._labels = None
    _roleB_handler_469._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])

    def run(self):
        loops = (int(sys.argv[1]) if (len(sys.argv) > 1) else 1)
        (skS, pkS) = keygen('public')
        (skA, pkA) = keygen('public')
        (skB, pkB) = keygen('public')
        S = self.new(roleS)
        B = self.new(roleB, (skB, S, pkS, loops))
        A = self.new(roleA, (skA, S, pkS, B, loops))
        self._setup(S, (skS, [(A, pkA), (B, pkB)], loops))
        self._start(S)
        self._start(B)
        self._start(A)
