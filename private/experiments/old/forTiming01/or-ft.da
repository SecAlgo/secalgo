"""
Otway-Rees Key Distribution Protocol
Written by Christopher Kane

Original Source:
Dave Otway and Owen Rees, "Efficient and Timely Mutual Authentication", ACM 
SIGOPS, v.21.1, Jan., 1987, pp. 8-10.

Immediate Source:
Security Protocol Open Repository
http://www.lsv.ens-cachan.fr/Software/spore/otwayRees.html

Protocol Diagram:
  (1) I -> R : M, I, R, enc((N_I, M, I, R), K_IS)
  (2) R -> S : M, I, R, enc((N_I, M, I, R), K_IS), enc((N_R, M, I, R), K_RS)
  (3) S -> R : M, enc((N_I, K_IR), K_IS), enc((N_R, k_IR), K_RS)
  (4) R -> I : M, enc((N_I, K_IR), K_IS)
"""
import time, json
from sa.sec_algo_pycrypto import genkey, encrypt, decrypt, gen_nonce

class RoleS (process):
    def setup(K_IS, K_RS):
        self.start_time = 0

    def run():
        self.start_time = time.process_time()
        if await(False): pass
        elif timeout(5): pass

    def receive(msg=(M, I, R, encI, encR), from_ = _R):
        send(encI, to = self)
        send(encR, to = self)
        await(some(received((N_I, _M, _I, _R), from_ = self),
                   received((N_R, _M, _I, _R), from_ = self),
                   has = N_R != N_I))
        K_IR = genkey('shared')
        send((M, ('encI', encrypt((N_I, K_IR), K_IS)),
             ('encR', encrypt((N_R, K_IR), K_RS))), to = R)
        print(json.dumps(['or-ft', 'roleS', self.start_time, time.process_time()]))

    def receive(msg=('encI', m), from_ = self):
        send((decrypt(m, K_IS)), to = self)

    def receive(msg=('encR', m), from_ = self):
        send((decrypt(m, K_RS)), to = self)
    
class RoleI (process):
    def setup(S, K_IS, R):
        self.I = self
        self.start_time = 0

    def run():
        self.start_time = time.process_time()
        M = gen_nonce()
        N_I = gen_nonce()
        send((M, I, R, ('encI', encrypt((N_I, M, I, R), K_IS))), to = R)
        await(some(received((_M, encI), from_ = R)))
        send(encI, to = self)
        await(some(received(((_N_I, K_IR), _S), from_ = self)))
        print(json.dumps(['or-ft', 'roleI', self.start_time, time.process_time()]))
        output('I - Key Exchange Complete')

    def receive(msg=('encI', m), from_ = self):
        send((decrypt(m, K_IS), S), to = self)

class RoleR (process):
    def setup(S, K_RS):
        self.R = self
        self.start_time = 0

    def run():
        self.start_time = time.process_time()
        if await(False): pass
        elif timeout(5): pass
        
    def receive(msg=(M, I, R, encI), from_ = I):
        N_R = gen_nonce()
        send((M, I, R, encI, ('encR', encrypt((N_R, M, I, R), K_RS))), to = S)
        await(some(received((_M, encI, encR), from_ = S)))
        send((M, encI), to = I)
        send(encR, to = self)
        await(some(received(((_N_R, K_IR), _S), from_ = self)))
        print(json.dumps(['or-ft', 'roleR', self.start_time, time.process_time()]))
        output('R - Key Exchange Complete')

    def receive(msg=('encR', m), from_ = self):
        send((decrypt(m, K_RS), S), to = self)
    
def main():
    K_IS = genkey('shared')
    K_RS = genkey('shared')
    S = new(RoleS, (K_IS, K_RS))
    R = new(RoleR, (S, K_RS))
    I = new(RoleI, (S, K_IS, R))
    start(S)
    start(R)
    start(I)
