import sys, time, random, pickle
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random import random
from Crypto.Hash import HMAC
from sa.Misc.Padding import pkcs7_pad as pad, pkcs7_unpad as unpad
DEFAULT_TGT_DURATION = 36000 # ten hours
DEFAULT_TKT_DURATION = 3600 # one hour
DEFAULT_SKEW = 300 # five minutes
KRB_AP_REQ_TYPE = 14 # msg-type value for krb_ap_req messages
ETYPE_AES_128_HMAC_SHA1_96 = 17 # cite
ETYPE_AES_256_HMAC_SHA1_96 = 18 # cite
CIPHER_AES = 0
MAC_HMAC = 0
CIPHERS = {CIPHER_AES : AES}
MACS = {MAC_HMAC : HMAC}
def set_security_params(etype):
    cipher = {ETYPE_AES_128_HMAC_SHA1_96 : CIPHER_AES, ETYPE_AES_256_HMAC_SHA1_96 : CIPHER_AES}
    mac = {ETYPE_AES_128_HMAC_SHA1_96 : MAC_HMAC, ETYPE_AES_256_HMAC_SHA1_96: MAC_HMAC}
    keySizes = {ETYPE_AES_128_HMAC_SHA1_96 : 16, ETYPE_AES_256_HMAC_SHA1_96 : 32}
    return (cipher[etype], keySizes[etype], mac[etype])
class RoleAuthServer(process):
    def setup(clients, servers, TGS, client_keys, server_keys, keyTGS):
        Random.atfork()
        self.supported_etypes = {ETYPE_AES_128_HMAC_SHA1_96, ETYPE_AES_128_HMAC_SHA1_96}
        self.max_tgt_duration = DEFAULT_TGT_DURATION
        self.skew = DEFAULT_SKEW
        self.per_client_lifetimes = dict()
        for c in clients:
            per_client_lifetimes[c] = DEFAULT_TGT_DURATION
        self.per_server_lifetimes = dict()
        for s in servers:
            per_server_lifetimes[s] = DEFAULT_TGT_DURATION
    def run():
        await(False)
    def receive(msg=('krb_as_req', pvno, msg_type, padata, req_body), from_ = C):
        (kdc_options, cname, realm, sname, krb_from, till, rtime, nonce, etype, addresses, enc_authorization_data, additional_tickets) = req_body
        if cname not in clients:
            return
        if sname not in servers:
            return
        chosen_etype = None
        for et in etype:
            if et in supported_etypes and chosen_etype == None:
                chosen_etype = et
        if chosen_etype == None:
            return
        params = set_security_params(chosen_etype)
        keyC_TGS = Random.new().read(params[1])
        if krb_from == None or (krb_from < (time.time() + skew)):
            tgt_start = time.time()
        else:
            return
        tgt_end = min(till, tgt_start + per_client_lifetimes[cname], tgt_start + per_server_lifetimes[sname], tgt_start + max_tgt_duration)
        tgt_enc_part = (dict(), (params, keyC_TGS), 'TEST', cname, [], tgt_start, tgt_start, tgt_end, None, [], [])
        tgtIV = Random.new().read(AES.block_size)
        tgtCipher = AES.new(keyTGS, AES.MODE_CBC, tgtIV)
        tgt = [5, 'TEST', sname, tgtIV + tgtCipher.encrypt(pad(pickle.dumps(tgt_enc_part)))]
        as_rep_enc_part = [(params, keyC_TGS), (0, 0), nonce, 0, dict(), tgt_start, tgt_start, tgt_end, 0, 'TEST', sname, []]
        asRepIV = Random.new().read(AES.block_size)
        asRepCipher = AES.new(client_keys[cname], AES.MODE_CBC, asRepIV)
        send(('krb_as_rep', 5, 11, [], 'TEST', cname, tgt, asRepIV + asRepCipher.encrypt(pad(pickle.dumps(as_rep_enc_part)))), to = C)
        output('AS - Sent TGT to client,', cname)
class RoleTGS(process):
    def setup(servers, AS, keyAS_TGS, server_keys):
        Random.atfork()
        self.supported_etypes = {ETYPE_AES_128_HMAC_SHA1_96, ETYPE_AES_128_HMAC_SHA1_96}
        self.skew = DEFAULT_SKEW
        self.max_tkt_duration = DEFAULT_TKT_DURATION
        self.per_server_lifetimes = dict()
        for s in server_keys:
            per_server_lifetimes[s] = DEFAULT_TKT_DURATION
    def run():
        await(False)
    def receive(msg=('krb_tgs_req', 5, 12, padata, req_body), from_ = C):
        _, msg_type, ap_options, tgt, authenticator = padata[0]
        if msg_type != 14:
            return # replace with function to report error
        (_, realm, sname, tgt_enc_part) = tgt
        tgtCipher = AES.new(keyAS_TGS, AES.MODE_CBC, tgt_enc_part[:AES.block_size]) 
        (tgt_flags, (paramsC_TGS, keyC_TGS), tgt_crealm, tgt_cname, tgt_transited, tgt_authtime, tgt_starttime, tgt_endtime, tgt_renew_till, tgt_caddr, tgt_authorization_data) = pickle.loads(unpad(tgtCipher.decrypt(tgt_enc_part[AES.block_size:])))
        cipherC_TGS = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC, authenticator[:CIPHERS[paramsC_TGS[0]].block_size])
        (_, au_crealm, au_cname, cksum, cusec, ctime, subkey, seq_number, authorization_data) = pickle.loads(unpad(cipherC_TGS.decrypt(authenticator[CIPHERS[paramsC_TGS[0]].block_size:])))
        if tgt_cname != au_cname or tgt_crealm != au_crealm:
            return
        local_time = time.time()
        if abs(local_time - ctime) > skew:
            return
        if tgt_starttime > local_time + skew:
            return
        if local_time - tgt_endtime > skew:
            return
        output('TGS - Authenticated client:', au_cname)
        (kdc_options, cname, realm, sname, krb_from, till, rtime, nonce, etype, addresses, enc_authorization_data, additional_tickets) = req_body
        if sname not in server_keys:
            return
        chosen_etype = None
        for et in etype:
            if et in supported_etypes and chosen_etype == None:
                chosen_etype = et
        if chosen_etype == None:
            return
        paramsC_S = set_security_params(chosen_etype)
        keyC_S = Random.new().read(paramsC_S[1])
        if krb_from == None or (krb_from < (local_time + skew)):
            ticket_start = local_time
        ticket_end = min(till, tgt_endtime, tgt_starttime + per_server_lifetimes[sname], tgt_starttime + max_tkt_duration)
        ticket_enc_part = [dict(), (paramsC_S, keyC_S), tgt_crealm, tgt_cname, tgt_transited, tgt_authtime, ticket_start, ticket_end, 0, tgt_caddr, []]
        tktIV = Random.new().read(AES.block_size)
        tktCipher = AES.new(server_keys[sname], AES.MODE_CBC, tktIV)
        new_ticket = [5, 'TEST', sname, tktIV + tktCipher.encrypt(pad(pickle.dumps(ticket_enc_part)))]
        tgs_rep_enc_part = [(paramsC_S, keyC_S), (0, 0), nonce, 0, dict(), tgt_authtime, ticket_start, ticket_end, 0, 'TEST', sname, tgt_caddr]
        output('TGS - Sent Ticket for server', sname, 'to client,', C)
        tgsRepIV = Random.new().read(CIPHERS[paramsC_TGS[0]].block_size)
        tgsRepCipher = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC, tgsRepIV)
        send(('krb_tgs_rep', 5, 13, [], 'TEST', tgt_cname, new_ticket, tgsRepIV + tgsRepCipher.encrypt(pad(pickle.dumps(tgs_rep_enc_part)))), to = C)        
class RoleAppServer(process):
    def setup(AS, TGS, keyS_AS, keyS_TGS):
        Random.atfork()
        self.S = self
        self.skew = DEFAULT_SKEW
    def run():
        await(False)
    def receive(msg=('krb_ap_req', 5, 14, ap-options, ticket, authenticator),
                from_ = C):
        tkt_vno, realm , sname, tkt_enc_part = ticket
        tktCipher = AES.new(keyS_TGS, AES.MODE_CBC, tkt_enc_part[:AES.block_size])
        (tkt_flags, (paramsC_S, keyC_S), tkt_crealm, tkt_cname, tkt_transited, tkt_authtime, tkt_starttime, tkt_endtime, tkt_renew_till, tkt_caddr, tkt_authorization_data) = pickle.loads(unpad(tktCipher.decrypt(tkt_enc_part[AES.block_size:])))
        cipherC_S = CIPHERS[paramsC_S[0]].new(keyC_S, CIPHERS[paramsC_S[0]].MODE_CBC, authenticator[:CIPHERS[paramsC_S[0]].block_size])
        (_, au_crealm, au_cname, au_cksum, au_cusec, au_ctime, au_subkey, au_seq_number, au_authorization_data) = pickle.loads(unpad(cipherC_S.decrypt(authenticator[CIPHERS[paramsC_S[0]].block_size:])))
        if au_crealm != tkt_crealm or au_cname != tkt_cname:
            return
        local_time = time.time()
        if abs(local_time - au_ctime) > skew:
            return
        if tkt_starttime > local_time + skew:
            return
        if local_time - tkt_endtime > skew:
            return
        output('Server:', S, '- Authenticated client:', au_cname)
class RoleC(process):
    def setup(realm, servers, AS, TGS, keyC_AS):
        Random.atfork()
        self.C = self
    def run():
        S = random.choice(tuple(servers))
        nonce_C_AS = random.StrongRandom().getrandbits(128)        
        as_req_body = [dict(), C, 'TEST', S, 0, time.time() + (5 * 3600), 0, nonce_C_AS, [ETYPE_AES_128_HMAC_SHA1_96, ETYPE_AES_256_HMAC_SHA1_96], [], [], []]
        output('Client - Sent request to AS for credentials for server,', S)
        send(('krb_as_req', 5, 10, [], as_req_body), to = AS)
        await(some(received(('krb_as_rep', 5, 11, padata, 'TEST', _C, tgt,
                             enc_part), from_= _AS)))
        asRepCipher = AES.new(keyC_AS, AES.MODE_CBC, enc_part[:AES.block_size])
        ((paramsC_TGS, keyC_TGS), last_req, as_nonce, key_expiration, flags, authtime, starttime, endtime, renew_till, srealm, sname, caddr) = pickle.loads(unpad(asRepCipher.decrypt(enc_part[AES.block_size:])))
        if as_nonce == nonce_C_AS:
            if sname == S and srealm == 'TEST':
                output('Client - Acquired TGT from AS')
        else:
            keyC_TGS = None
            tgt = None
        if tgt != None:
            tgsReqIV = Random.new().read(CIPHERS[paramsC_TGS[0]].block_size)
            tgsReqCipher = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC, tgsReqIV)
            authenticator = [5, realm, C, None, 0, time.time(), None, None, []]
            tgs_krb_ap_req = [5, 14, dict(), tgt, tgsReqIV + tgsReqCipher.encrypt(pad(pickle.dumps(authenticator)))]
            nonceC_TGS = random.StrongRandom().getrandbits(128)
            tgs_req_body = [dict(), None, 'TEST', S, 0, time.time() + (5 * 3600), 0, nonceC_TGS, [ETYPE_AES_128_HMAC_SHA1_96, ETYPE_AES_256_HMAC_SHA1_96], [], [], []]
            output('Client - Sent TGT and request to TGS for credentials',
                   'for server,', S)
            send(('krb_tgs_req',5, 12, [tgs_krb_ap_req], tgs_req_body), to = TGS)
            await(some(received(('krb_tgs_rep', 5, 13, tgs_padata, 'TEST', _C, ticket, tgs_enc_part), from_ = _TGS)))
            tgsRepCipher = CIPHERS[paramsC_TGS[0]].new(keyC_TGS, CIPHERS[paramsC_TGS[0]].MODE_CBC, tgs_enc_part[:CIPHERS[paramsC_TGS[0]].block_size])
            ((paramsC_S, keyC_S), tgs_last_req, tgs_nonce, tgs_key_expiration, tgs_flags, tgs_authtime, tgs_starttime, tgs_endtime, tgs_renew_till, tgs_srealm, tgs_sname, tgs_caddr) = pickle.loads(unpad(tgsRepCipher.decrypt(tgs_enc_part[CIPHERS[paramsC_TGS[0]].block_size:])))
            if tgs_nonce == nonceC_TGS:
                if tgs_sname == S and tgs_srealm == 'TEST':
                    output('Client - Acquired Ticket from TGS')
            else:
                keyC_S = None
                ticket = None
        if keyC_S != None:
            ap_authenticator = [5, realm, C, None, None, time.time(), None, None, []]
            apReqIV = Random.new().read(CIPHERS[paramsC_S[0]].block_size)
            apReqCipher = CIPHERS[paramsC_S[0]].new(keyC_S, CIPHERS[paramsC_S[0]].MODE_CBC, apReqIV)
            send(('krb_ap_req', 5, 14, dict(), ticket, apReqIV + apReqCipher.encrypt(pad(pickle.dumps(ap_authenticator)))), to = S)
            output('Client - Sent authentication request to server,', S)
        
def main():
    num_clients = int(sys.argv[1]) if len(sys.argv) > 1 else 10
    num_servers = int(sys.argv[2]) if len(sys.argv) > 2 else 10
    C = new(RoleC, num = num_clients)
    S = new(RoleAppServer, num = num_servers)
    TGS = new(RoleTGS)
    AS = new(RoleAuthServer)
    client_keys = dict()
    for client in C:
        keyC_AS = Random.new().read(32)
        setup(client, ('TEST', S, AS, TGS, keyC_AS))
        client_keys[client] = keyC_AS
    as_server_keys = dict()
    tgs_server_keys = dict()
    for server in S:
        keyS_AS = Random.new().read(32)
        as_server_keys[server] = keyS_AS
        keyS_TGS = Random.new().read(32)
        tgs_server_keys[server] = keyS_TGS
        setup(server, (AS, TGS, keyS_AS, keyS_TGS))
    keyAS_TGS = Random.new().read(32)
    setup(AS, (C, S, TGS, client_keys, as_server_keys, keyAS_TGS))
    setup(TGS, (S, AS, keyAS_TGS, tgs_server_keys))
    start(AS)
    start(TGS)
    start(S)
    start(C)
