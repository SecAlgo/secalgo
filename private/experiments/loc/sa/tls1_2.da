import time, sys, pickle
from Crypto.Hash import SHA256
from Crypto.Hash import HMAC
from sa.secalgo import *
configure(verify_returns = 'bool')
PROTOCOL_VERSION_3_0 = (3, 0) #SSL 3.0
PROTOCOL_VERSION_1_0 = (3, 1) #TLS 1.0
PROTOCOL_VERSION_1_1 = (3, 2) #TLS 1.1
PROTOCOL_VERSION_1_2 = (3, 3) #TLS 1.2
TYPE_CHANGE_CIPHER_SPEC = 20
TYPE_ALERT              = 21
TYPE_HANDSHAKE          = 22
TYPE_APPLICATION_DATA   = 23
VERIFY_DATA_LENGTH = 12
CHANGE_CIPHER_SPEC_BODY = 1
HELLO_REQUEST       = 0
CLIENT_HELLO        = 1
SERVER_HELLO        = 2
CERTIFICATE         = 11
SERVER_KEY_EXCHANGE = 12
CERTIFICATE_REQUEST = 13
SERVER_HELLO_DONE   = 14
CERTIFICATE_VERIFY  = 15
CLIENT_KEY_EXCHANGE = 16
FINISHED            = 20
RSA_SIGN                  = 1
DSS_SIGN                  = 2
RSA_FIXED_DH              = 3
DSS_FIXED_DH              = 4
RSA_EPHEMERAL_DH_RESERVED = 5
DSS_EPHEMERAL_DH_RESERVED = 6
FORTEZZA_DMS_RESERVED     = 20
CONN_SERVER = 0
CONN_CLIENT = 1
TLS_PRF_SHA256 = 0
CIPHER_STREAM = 0
CIPHER_BLOCK  = 1
CIPHER_AEAD   = 2
BULK_NULL = 0
BULK_RC4  = 1
BULK_3DES = 2
BULK_AES  = 3
MAC_NULL        = 0
MAC_HMAC_MD5    = 1
MAC_HMAC_SHA1   = 2
MAC_HMAC_SHA256 = 3
MAC_HMAC_SHA384 = 4
MAC_HMAC_SHA512 = 5
COMP_NULL = 0
TLS_NULL_WITH_NULL_NULL         = (0, 0)
TLS_RSA_WITH_AES_128_CBC_SHA256 = (0, 60)
TLS_RSA_WITH_AES_256_CBC_SHA256 = (0, 61)
SIG_ANONYMOUS = 0
SIG_RSA       = 1
SIG_DSA       = 2
SIG_ECDSA     = 3
HASH_NONE   = 0
HASH_MD5    = 1
HASH_SHA1   = 2
HASH_SHA224 = 3
HASH_SHA256 = 4
HASH_SHA384 = 5
HASH_SHA512 = 6
KE_NULL    = 0
KE_RSA     = 1
KE_DH_DSS  = 2
KE_DH_RSA  = 3
KE_DHE_DSS = 4
KE_DHE_DSS = 5
KE_DH_ANON = 6
def _a(n, secret, seed):
    if n == 0:
        return seed
    else:
        h = HMAC.new(secret, digestmod = SHA256)
        h.update(_a(n - 1, secret, seed))
        return h.digest()
def _p_hash(secret, seed, output_length):
    result = bytearray()
    i = 1
    while len(result) < output_length:
        h = HMAC.new(secret, digestmod = SHA256)
        h.update(_a(i, secret, seed))
        h.update(seed)
        result.extend(h.digest())
        i += 1
    return bytes(result[:output_length])
def tls_prf_sha256(secret, label, seed, output_length):
    return _p_hash(secret, label + seed, output_length)
class Security_Parameters():
    def __init__(self, ce):
        self.connection_end = ce
        self.prf_algorithm = TLS_PRF_SHA256
        self.bulk_cipher_algorithm = BULK_NULL
        self.cipher_type = CIPHER_STREAM
        self.enc_key_length = 0
        self.block_length = None
        self.fixed_iv_length = 0
        self.record_iv_length = 0
        self.mac_algorithm = MAC_NULL
        self.mac_length = 0
        self.mac_key_length = 0
        self.compression_method = COMP_NULL
        self.master_secret = None
        self.client_random = None
        self.server_random = None
class Connection_State():
    def __init__(self):
        self.compression_state = None
        self.cipher_state = None
        self.mac_key = None
        self.sequence_number = 0
class TLS_Peer(process):
    def setup(ce, peer, secret_key, public_key, certificate_list):
        self.max_hs_id = 0
        self.supported_tls_versions = (PROTOCOL_VERSION_1_2,)
        self.supported_cipher_suites = (TLS_RSA_WITH_AES_256_CBC_SHA256,)
        self.supported_compression_methods = (COMP_NULL,)
        self.current_rsp = Security_Parameters(ce)
        self.current_wsp = Security_Parameters(ce)
        self.pending_rsp = Security_Parameters(ce)
        self.pending_wsp = Security_Parameters(ce)
        self.current_read_state = Connection_State()
        self.current_write_state = Connection_State()
        self.pending_read_state = Connection_State()
        self.pending_write_state = Connection_State()        
    def record_wrapper(content_type, tls_message):
        version = PROTOCOL_VERSION_1_2
        pt_fragment = tls_message
        pt_length = None
        tls_pt = (content_type, version, pt_length, pt_fragment)
        comp_length = pt_length
        if current_wsp.compression_method != COMP_NULL:
            comp_fragment = current_wsp.compression_method(pt_fragment)
        else:
            comp_fragment = pt_fragment
        tls_comp = (content_type, version, comp_length, comp_fragment)
        cipher_length = comp_length
        if current_wsp.cipher_type == CIPHER_STREAM:
            if current_wsp.mac_algorithm == MAC_NULL:
                cipher_mac = b''
            else:
                cipher_mac = sign((current_write_state.sequence_number, content_type, version, comp_length, comp_fragment), key = current_write_state.mac_key)
            stream_ciphered = (comp_fragment, cipher_mac)
            if current_wsp.bulk_cipher_algorithm != BULK_NULL:
                cipher_fragment = encrypt(stream_ciphered, key = current_write_state.cipher_state[0])
            else:
                cipher_fragment = stream_ciphered
        elif current_wsp.cipher_type == CIPHER_BLOCK:
            iv = keygen('random', current_wsp.record_iv_length)
            if current_wsp.mac_algorithm == MAC_NULL:
                cipher_mac = b''
            else:
                cipher_mac = sign((current_write_state.sequence_number, content_type, version, comp_length, comp_fragment), key = current_write_state.mac_key)
            cipher_padding = b''
            cipher_pad_length = 0
            block_ciphered = (comp_fragment, cipher_mac, cipher_padding, cipher_pad_length)
            cipher_fragment = (iv, encrypt(block_ciphered, key = current_write_state.cipher_state[0]))
        tls_cipher = (content_type, version, cipher_length, cipher_fragment)
        return tls_cipher
    def record_unwrapper(tls_cipher):
        content_type, version, cipher_length, cipher_fragment = tls_cipher
        if version != PROTOCOL_VERSION_1_2:
            return
        if current_rsp.cipher_type == CIPHER_STREAM:
            if current_rsp.bulk_cipher_algorithm == BULK_NULL:
                (comp_fragment, cipher_mac) = cipher_fragment
            else:
                (comp_fragment, cipher_mac) = decrypt(cipher_fragment, key = current_read_state.cipher_state[0])
        elif current_rsp.cipher_type == CIPHER_BLOCK:
            (iv, block_ciphered) = cipher_fragment
            (comp_fragment, cipher_mac, cipher_padding, cipher_pad_length) = decrypt(block_ciphered, key = current_read_state.cipher_state[0])
        comp_length = cipher_length
        if current_rsp.mac_algorithm != MAC_NULL:
            if not verify(((current_read_state.sequence_number, content_type, version, comp_length, comp_fragment), cipher_mac), key = current_read_state.mac_key):
                output('MAC VERIFICATION ERROR')
                return
        pt_length = comp_length
        if current_rsp.compression_method != COMP_NULL:
            pt_fragment = current_rsp.compression_method(comp_fragment, 'decompress')
        else:
            pt_fragment = comp_fragment
        return pt_fragment
    def update_pending_parameters(cipher_suite, comp_method, crand, srand):
        pending_rsp.compression_method = comp_method
        pending_rsp.client_random = crand
        pending_rsp.server_random = srand
        pending_wsp.compression_method = comp_method
        pending_wsp.client_random = crand
        pending_wsp.server_random = srand
        if cipher_suite == TLS_RSA_WITH_AES_256_CBC_SHA256:
            pending_rsp.bulk_cipher_algorithm = BULK_AES
            pending_rsp.cipher_type = CIPHER_BLOCK
            pending_rsp.enc_key_length = 32
            pending_rsp.block_length = 16
            pending_rsp.fixed_iv_length = 16
            pending_rsp.record_iv_length = 16
            pending_rsp.mac_algorithm = MAC_HMAC_SHA256
            pending_rsp.mac_length = 32
            pending_rsp.mac_key_length = 32
            pending_wsp.bulk_cipher_algorithm = BULK_AES
            pending_wsp.cipher_type = CIPHER_BLOCK
            pending_wsp.enc_key_length = 32
            pending_wsp.block_length = 16
            pending_wsp.fixed_iv_length = 16
            pending_wsp.record_iv_length = 16
            pending_wsp.mac_algorithm = MAC_HMAC_SHA256
            pending_wsp.mac_length = 32
            pending_wsp.mac_key_length = 32
            return KE_RSA
        return KE_NULL
    def update_connection_state():
        key_block_length = (2 * (pending_wsp.enc_key_length + pending_wsp.mac_key_length))
        key_block = tls_prf_sha256(pending_wsp.master_secret, b'key expansion', (pending_wsp.client_random + pending_wsp.server_random), key_block_length)
        first_slice = pending_wsp.mac_key_length
        second_slice = first_slice + pending_wsp.mac_key_length
        third_slice = second_slice + pending_wsp.enc_key_length
        fourth_slice = third_slice + pending_wsp.enc_key_length
        first_block = key_block[:first_slice]
        second_block = key_block[first_slice:second_slice]
        third_block = key_block[second_slice:third_slice]
        fourth_block = key_block[third_slice:]
        if pending_wsp.connection_end == CONN_CLIENT:
            pending_write_state.mac_key = keygen('mac', key_mat = first_block)
            pending_read_state.mac_key = keygen('mac', key_mat = second_block)
            pending_write_state.cipher_state = [keygen('shared', key_mat = third_block)]
            pending_read_state.cipher_state = [keygen('shared', key_mat = fourth_block)]
        else:
            pending_read_state.mac_key = keygen('mac', key_mat = first_block)
            pending_write_state.mac_key = keygen('mac', key_mat = second_block)
            pending_read_state.cipher_state = [keygen('shared', key_mat = third_block)]
            pending_write_state.cipher_state = [keygen('shared', key_mat = fourth_block)]
    def initiate_handshake(server):
        output('CLIENT - begin Handshake')
        handshake_id = (self, max_hs_id)
        max_hs_id += 1
        msg_counter = 0
        handshake_messages = []
        current_rsp.connection_end = CONN_CLIENT
        current_wsp.connection_end = CONN_CLIENT
        pending_rsp.connection_end = CONN_CLIENT
        pending_wsp.connection_end = CONN_CLIENT
        client_random = (time.time(), keygen('random', 28))
        body_ch = (PROTOCOL_VERSION_1_2, client_random, None, (TLS_RSA_WITH_AES_256_CBC_SHA256,), (0,), None)
        handshake_ch = (CLIENT_HELLO, None, body_ch)
        handshake_messages.append(handshake_ch)
        msg_counter += 1
        send((record_wrapper(TYPE_HANDSHAKE, handshake_ch), handshake_id, msg_counter), to = server)
        await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and SERVER_HELLO == record_unwrapper(msg)[0])))
        msg_counter = counter
        handshake_sh = record_unwrapper(msg)
        handshake_messages.append(handshake_sh)
        (_, _, body_sh) = handshake_sh
        (server_version, server_random, session_id, cipher_suite, compression_method, extensions) = body_sh
        if server_version != PROTOCOL_VERSION_1_2:
            return
        key_exchange_alg = update_pending_parameters(cipher_suite, compression_method, client_random[1], server_random[1])
        if key_exchange_alg not in {KE_NULL, KE_DH_ANON}:
            await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and CERTIFICATE  == record_unwrapper(msg)[0])))
            msg_counter = counter
            handshake_sc = record_unwrapper(msg)
            handshake_messages.append(handshake_sc)
            (_, _, body_cert) = handshake_sc
            (cert_list,) = body_cert
            verdict = True
            for i, cert in enumerate(cert_list):
                if i < (len(cert_list) - 1):
                    if not verify(((cert[0], cert[1]), cert[2]), key = cert_list[i + 1][1]):
                        verdict = False
                else:
                    if not verify(((cert[0], cert[1]), cert[2]), key = cert[1]):
                        verdict = False
            if not verdict:
                output('CLIENT - CERTIFICATE AUTHENTICATION FAILURE')
                return
            server_public_key = cert_list[0][1]
        if key_exchange_alg not in {KE_NULL, KE_RSA, KE_DH_DSS, KE_DH_RSA}:
            await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and (SERVER_KEY_EXCHANGE == record_unwrapper(msg)[0]))))
            msg_counter = counter
            pass
        if key_exchange_alg not in {KE_NULL, KE_DH_ANON}:
            if await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and (CERTIFICATE_REQUEST == record_unwrapper(msg)[0])))):
                msg_counter = counter
                pass
            elif some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and SERVER_HELLO_DONE == record_unwrapper(msg)[0])):
                pass
        await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and SERVER_HELLO_DONE == record_unwrapper(msg)[0])))
        msg_counter = counter
        handshake_shd = record_unwrapper(msg)
        handshake_messages.append(handshake_shd)
        pre_master_secret = (PROTOCOL_VERSION_1_2, keygen('random', 46))
        encrypted_pre_master_secret = (encrypt(pre_master_secret, key = server_public_key),)
        body_cke = (encrypted_pre_master_secret,)
        handshake_cke = (CLIENT_KEY_EXCHANGE, None, body_cke)
        handshake_messages.append(handshake_cke)
        msg_counter += 1
        send((record_wrapper(TYPE_HANDSHAKE, handshake_cke), handshake_id, msg_counter), to = server)
        pms = bytes(pre_master_secret[0]) + pre_master_secret[1]
        msecret = tls_prf_sha256(pms, b'master secret', (pending_wsp.client_random + pending_wsp.server_random), 48)
        pending_wsp.master_secret = msecret
        pending_rsp.master_secret = msecret
        update_connection_state()
        handshake_ccs = (CHANGE_CIPHER_SPEC_BODY,)
        msg_counter += 1
        send((record_wrapper(TYPE_CHANGE_CIPHER_SPEC, handshake_ccs), handshake_id, msg_counter), to = server)
        current_wsp = pending_wsp
        current_write_state = pending_write_state
        pending_wsp = Security_Parameters(current_wsp.connection_end)
        pending_write_state = Connection_State()
        shm = b''
        m_count = 1
        for m in handshake_messages:
            shm += b'msg' + str(m_count).encode('ascii')
            m_count += 1
        print('CLIENT_SHM1:\n', shm)
        verification_data = tls_prf_sha256(current_wsp.master_secret, b'client finished', SHA256.new(shm).digest(), VERIFY_DATA_LENGTH)
        print('CURRENT_WSP_MS:\n', current_wsp.master_secret)
        print('HASH:', SHA256.new(shm).digest())
        print('CLIENT:\n', verification_data)
        finished = (verification_data,)
        handshake_cfin = (FINISHED, None, finished)
        handshake_messages.append(handshake_cfin)
        shm += b'msg' + str(m_count).encode('ascii')
        print('CLIENT_SHM2:\n', shm)
        msg_counter += 1
        send((record_wrapper(TYPE_HANDSHAKE, handshake_cfin), handshake_id, msg_counter), to = server)
        await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_CHANGE_CIPHER_SPEC and counter > msg_counter)))
        msg_counter = counter
        await(some(received((msg, _handshake_id, counter), from_ = server), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and FINISHED == record_unwrapper(msg)[0])))
        msg_counter = counter
        (_, _, (finish_data,)) = record_unwrapper(msg)
        client_data = tls_prf_sha256(current_rsp.master_secret, b'server finished', SHA256.new(shm).digest(), VERIFY_DATA_LENGTH)
        if client_data != finish_data:
            output('CLIENT - Handshake Failed')
            return
        output('CLIENT - Handshake complete')
    def receive(msg=((22, _PROTOCOL_VERSION_1_2, None, cipher_fragment), handshake_id, counter), from_ = client):
        msg_counter = counter
        handshake_messages = []
        handshake_msg = record_unwrapper((TYPE_HANDSHAKE, PROTOCOL_VERSION_1_2, None, cipher_fragment))
        if CLIENT_HELLO != handshake_msg[0]:
            return
        output('SERVER - begin Handshake')
        current_rsp.connection_end = CONN_SERVER
        current_wsp.connection_end = CONN_SERVER
        pending_rsp.connection_end = CONN_SERVER
        pending_wsp.connection_end = CONN_SERVER
        handshake_messages.append(handshake_msg)
        (client_version, client_random, session_id, cipher_suites, compression_methods, extensions) = handshake_msg[2]
        server_version = min(client_version, max(supported_tls_versions))
        server_random = (time.time(), keygen('random', 28))
        if session_id != None:
            output('Client attempting abbreivated handshake.')
        else:
            session_id = None
            cipher_suite = setof(suite, suite in cipher_suites, suite in supported_cipher_suites).pop()
            compression_method = setof(method, method in compression_methods, method in supported_compression_methods).pop()
            body_sh = (server_version, server_random, session_id, cipher_suite, compression_method, extensions)
            handshake_sh = (SERVER_HELLO, None, body_sh)
            handshake_messages.append(handshake_sh)
            msg_counter += 1
            send((record_wrapper(TYPE_HANDSHAKE, handshake_sh), handshake_id, msg_counter), to = client)
            key_exchange_alg = update_pending_parameters(cipher_suite, compression_method, client_random[1], server_random[1])
            body_sc = (certificate_list,)
            handshake_sc = (CERTIFICATE, None, body_sc)
            handshake_messages.append(handshake_sc)
            msg_counter += 1
            send((record_wrapper(TYPE_HANDSHAKE, handshake_sc), handshake_id, msg_counter), to = client)
            body_shd = ()
            handshake_shd = (SERVER_HELLO_DONE, None, body_shd)
            handshake_messages.append(handshake_shd)
            msg_counter += 1
            send((record_wrapper(TYPE_HANDSHAKE, handshake_shd), handshake_id, msg_counter), to = client)
            await(some(received((msg, _handshake_id, counter), from_ = client), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and (CLIENT_KEY_EXCHANGE == record_unwrapper(msg)[0]))))
            msg_counter = counter
            handshake_cke = record_unwrapper(msg)
            handshake_messages.append(handshake_cke)
            (_, _, body_cke) = handshake_cke
            pre_master_secret = decrypt(body_cke[0][0], key = secret_key)
            pms = bytes(pre_master_secret[0]) + pre_master_secret[1]
            msecret = tls_prf_sha256(pms, b'master secret', (pending_wsp.client_random + pending_wsp.server_random), 48)
            pending_wsp.master_secret = msecret
            pending_rsp.master_secret = msecret
            update_connection_state()
            await(some(received((msg, _handshake_id, counter), from_ = client), has = (msg[0] == TYPE_CHANGE_CIPHER_SPEC and counter > msg_counter)))
            msg_counter = counter
            await(some(received((msg, _handshake_id, counter), from_ = client), has = (msg[0] == TYPE_HANDSHAKE and counter > msg_counter and FINISHED == record_unwrapper(msg)[0])))
            msg_counter = counter
            handshake_cfin = record_unwrapper(msg)
            (_, _, (finish_data,)) = handshake_cfin
            shm = b''
            m_count = 1
            for m in handshake_messages:
                shm += b'msg' + str(m_count).encode('ascii')
                m_count += 1
            print('SERVER_SHM1:\n', shm)
            server_data = tls_prf_sha256(current_rsp.master_secret, b'client finished', SHA256.new(shm).digest(), VERIFY_DATA_LENGTH)
            if server_data != finish_data:
                output('SERVER - Handshake failed')
                return
            handshake_messages.append(handshake_cfin)
            shm += b'msg' + str(m_count).encode('ascii')
            print('SERVER_SHM2:\n', shm)
            handshake_ccs = (CHANGE_CIPHER_SPEC_BODY,)
            msg_counter += 1
            send((record_wrapper(TYPE_CHANGE_CIPHER_SPEC, handshake_ccs), handshake_id, msg_counter), to = client)
            current_wsp = pending_wsp
            current_write_state = pending_write_state
            pending_wsp = Security_Parameters(current_wsp.connection_end)
            pending_write_state = Connection_State()
            verification_data = tls_prf_sha256(current_wsp.master_secret, b'server finished', SHA256.new(shm).digest(), VERIFY_DATA_LENGTH)
            finished = (verification_data,)
            handshake_sfin = (FINISHED, None, finished)
            msg_counter += 1
            send((record_wrapper(TYPE_HANDSHAKE, handshake_sfin), handshake_id, msg_counter), to = client)
            output('SERVER - Handshake Complete')
    def receive(msg=((20, _PROTOCOL_VERSION_1_2, None, cipher_fragment), handshake_id, msg_counter)):
        output('CHANGE_CIPHER_SPEC!!!!!!!!!!!!!!!!!!!')
        current_rsp = pending_rsp
        current_read_state = pending_read_state
        pending_rsp = Security_Parameters(current_rsp.connection_end)
        pending_read_state = Connection_State()
    def run():
        if peer != None:
            initiate_handshake(peer)
        else:
            await(False)
def main():
    config(channel = 'reliable')
    tls_server = new(TLS_Peer)
    tls_client = new(TLS_Peer)
    sk_root, pk_root = keygen('public')
    sk_server, pk_server = keygen('public')
    server_certificate = ('server', pk_server, sign(('server', pk_server), key = sk_root))
    root_certificate = ('root', pk_root, sign(('root', pk_root), key = sk_root))
    certificate_list = (server_certificate, root_certificate)
    setup(tls_server, (CONN_SERVER, None, sk_server, pk_server, certificate_list))
    setup(tls_client, (CONN_CLIENT, tls_server, None, None, None))
    start(tls_server)
    start(tls_client)
