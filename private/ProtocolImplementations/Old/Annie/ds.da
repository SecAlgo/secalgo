"""
(1) A -> B: enc(sign(k, skA), pkB)
(2) B -> A: enc(s, k)
"""

def genkey(): return 3  # generate a shared/secrete key
def pk(p): return p  # return public key of p
def sign(m,sk): return m  # sign m with secrete key k
def check(m,pk): return m
def aenc(m,pk): return m  # asymetric encription of m with public key pk
def adec(m,sk): return m
def senc(m,k): return m  # symetric encription of m with shared key k
def sdec(m,k): return m

class roleA (process):
  def send(m, to= None): super().send (m, to= to); output('send', m, 'to', to)

  def setup(skA, B): pass
  def run():
    k = genkey()
    send (('aenc_sign', aenc(sign(k, skA), pk(B))), to= B)
    await (some(received(m, from_= B)))
    s = sdec(m,k)

class roleB (process):
  def send(m, to= None): super().send (m, to= to); output('send', m, 'to', to)

  def setup(skB): self.s = "secrete"
  def run(): await(False)
  def receive (msg=('aenc_sign', m), from_= A):
    k = check(adec(m, skB), pk(A))
    send (senc(s, k), to= A)

def main():
  skA = 1
  skB = 2
  B = new(roleB, (skB,))
  A = new(roleA, (skA, B))
  start(A)
  start(B)





"""
from 535 lecture fall 2015

def pk(sk): pass # return public key of 

class P extends process:
  def setup(skA, pkB): pass  # sk of self, pk of another
    s = "my_secrete"

  def main():
    k = gensym()
    send encrypt(sign(k, skA), pkB) to b
    await (received(m, from_= b))
      s = decrypt(m,k)

  receive m from b:
    k = checksign(decrypt(m,skA), pkB)
    send encrypt(s,k) to b

def main():
  skA = input()
  skB = input()
  pkA = pk(skA)
  pkB = pk(skB)
  a = new(P, [skA, pkB])
  b = new(P, [skB, pkA])
"""
